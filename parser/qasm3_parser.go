// Code generated from qasm3Parser.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // qasm3Parser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type qasm3Parser struct {
	*antlr.BaseParser
}

var Qasm3ParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func qasm3parserParserInit() {
	staticData := &Qasm3ParserParserStaticData
	staticData.LiteralNames = []string{
		"", "'OPENQASM'", "'include'", "'defcalgrammar'", "'def'", "'cal'",
		"'defcal'", "'gate'", "'extern'", "'box'", "'let'", "'break'", "'continue'",
		"'if'", "'else'", "'end'", "'return'", "'for'", "'while'", "'in'", "'switch'",
		"'case'", "'default'", "", "", "'input'", "'output'", "'const'", "'readonly'",
		"'mutable'", "'qreg'", "'qubit'", "'creg'", "'bool'", "'bit'", "'int'",
		"'uint'", "'float'", "'angle'", "'complex'", "'array'", "'void'", "'duration'",
		"'stretch'", "'gphase'", "'inv'", "'pow'", "'ctrl'", "'negctrl'", "'#dim'",
		"'durationof'", "'delay'", "'reset'", "'measure'", "'barrier'", "",
		"'['", "']'", "'{'", "'}'", "'('", "')'", "':'", "';'", "'.'", "','",
		"'='", "'->'", "'+'", "'++'", "'-'", "'*'", "'**'", "'/'", "'%'", "'|'",
		"'||'", "'&'", "'&&'", "'^'", "'@'", "'~'", "'!'", "", "", "", "", "'im'",
	}
	staticData.SymbolicNames = []string{
		"", "OPENQASM", "INCLUDE", "DEFCALGRAMMAR", "DEF", "CAL", "DEFCAL",
		"GATE", "EXTERN", "BOX", "LET", "BREAK", "CONTINUE", "IF", "ELSE", "END",
		"RETURN", "FOR", "WHILE", "IN", "SWITCH", "CASE", "DEFAULT", "PRAGMA",
		"AnnotationKeyword", "INPUT", "OUTPUT", "CONST", "READONLY", "MUTABLE",
		"QREG", "QUBIT", "CREG", "BOOL", "BIT", "INT", "UINT", "FLOAT", "ANGLE",
		"COMPLEX", "ARRAY", "VOID", "DURATION", "STRETCH", "GPHASE", "INV",
		"POW", "CTRL", "NEGCTRL", "DIM", "DURATIONOF", "DELAY", "RESET", "MEASURE",
		"BARRIER", "BooleanLiteral", "LBRACKET", "RBRACKET", "LBRACE", "RBRACE",
		"LPAREN", "RPAREN", "COLON", "SEMICOLON", "DOT", "COMMA", "EQUALS",
		"ARROW", "PLUS", "DOUBLE_PLUS", "MINUS", "ASTERISK", "DOUBLE_ASTERISK",
		"SLASH", "PERCENT", "PIPE", "DOUBLE_PIPE", "AMPERSAND", "DOUBLE_AMPERSAND",
		"CARET", "AT", "TILDE", "EXCLAMATION_POINT", "EqualityOperator", "CompoundAssignmentOperator",
		"ComparisonOperator", "BitshiftOperator", "IMAG", "ImaginaryLiteral",
		"BinaryIntegerLiteral", "OctalIntegerLiteral", "DecimalIntegerLiteral",
		"HexIntegerLiteral", "Identifier", "HardwareQubit", "FloatLiteral",
		"TimingLiteral", "BitstringLiteral", "Whitespace", "Newline", "LineComment",
		"BlockComment", "VERSION_IDENTIFER_WHITESPACE", "VersionSpecifier",
		"ARBITRARY_STRING_WHITESPACE", "StringLiteral", "EAT_INITIAL_SPACE",
		"EAT_LINE_END", "RemainingLineContent", "CAL_PRELUDE_WHITESPACE", "CAL_PRELUDE_COMMENT",
		"DEFCAL_PRELUDE_WHITESPACE", "DEFCAL_PRELUDE_COMMENT", "CalibrationBlock",
	}
	staticData.RuleNames = []string{
		"program", "version", "statement", "annotation", "scope", "pragma",
		"statementOrScope", "calibrationGrammarStatement", "includeStatement",
		"breakStatement", "continueStatement", "endStatement", "forStatement",
		"ifStatement", "returnStatement", "whileStatement", "switchStatement",
		"switchCaseItem", "barrierStatement", "boxStatement", "delayStatement",
		"gateCallStatement", "measureArrowAssignmentStatement", "resetStatement",
		"aliasDeclarationStatement", "classicalDeclarationStatement", "constDeclarationStatement",
		"ioDeclarationStatement", "oldStyleDeclarationStatement", "quantumDeclarationStatement",
		"defStatement", "externStatement", "gateStatement", "assignmentStatement",
		"expressionStatement", "calStatement", "defcalStatement", "expression",
		"aliasExpression", "declarationExpression", "measureExpression", "rangeExpression",
		"setExpression", "arrayLiteral", "indexOperator", "indexedIdentifier",
		"returnSignature", "gateModifier", "scalarType", "qubitType", "arrayType",
		"arrayReferenceType", "designator", "defcalTarget", "defcalArgumentDefinition",
		"defcalOperand", "gateOperand", "externArgument", "argumentDefinition",
		"argumentDefinitionList", "defcalArgumentDefinitionList", "defcalOperandList",
		"expressionList", "identifierList", "gateOperandList", "externArgumentList",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 113, 826, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2,
		63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 1, 0, 3, 0, 134, 8, 0, 1, 0, 5,
		0, 137, 8, 0, 10, 0, 12, 0, 140, 9, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 2, 1, 2, 5, 2, 150, 8, 2, 10, 2, 12, 2, 153, 9, 2, 1, 2, 1, 2, 1,
		2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1,
		2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1,
		2, 1, 2, 1, 2, 3, 2, 184, 8, 2, 3, 2, 186, 8, 2, 1, 3, 1, 3, 3, 3, 190,
		8, 3, 1, 4, 1, 4, 5, 4, 194, 8, 4, 10, 4, 12, 4, 197, 9, 4, 1, 4, 1, 4,
		1, 5, 1, 5, 1, 5, 1, 6, 1, 6, 3, 6, 206, 8, 6, 1, 7, 1, 7, 1, 7, 1, 7,
		1, 8, 1, 8, 1, 8, 1, 8, 1, 9, 1, 9, 1, 9, 1, 10, 1, 10, 1, 10, 1, 11, 1,
		11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 3, 12, 235, 8, 12, 1, 12, 1, 12, 1, 13, 1, 13, 1, 13, 1, 13, 1,
		13, 1, 13, 1, 13, 3, 13, 246, 8, 13, 1, 14, 1, 14, 1, 14, 3, 14, 251, 8,
		14, 1, 14, 1, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 16, 1, 16,
		1, 16, 1, 16, 1, 16, 1, 16, 5, 16, 267, 8, 16, 10, 16, 12, 16, 270, 9,
		16, 1, 16, 1, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 3, 17, 280,
		8, 17, 1, 18, 1, 18, 3, 18, 284, 8, 18, 1, 18, 1, 18, 1, 19, 1, 19, 3,
		19, 290, 8, 19, 1, 19, 1, 19, 1, 20, 1, 20, 1, 20, 3, 20, 297, 8, 20, 1,
		20, 1, 20, 1, 21, 5, 21, 302, 8, 21, 10, 21, 12, 21, 305, 9, 21, 1, 21,
		1, 21, 1, 21, 3, 21, 310, 8, 21, 1, 21, 3, 21, 313, 8, 21, 1, 21, 3, 21,
		316, 8, 21, 1, 21, 1, 21, 1, 21, 1, 21, 5, 21, 322, 8, 21, 10, 21, 12,
		21, 325, 9, 21, 1, 21, 1, 21, 1, 21, 3, 21, 330, 8, 21, 1, 21, 3, 21, 333,
		8, 21, 1, 21, 3, 21, 336, 8, 21, 1, 21, 3, 21, 339, 8, 21, 1, 21, 3, 21,
		342, 8, 21, 1, 22, 1, 22, 1, 22, 3, 22, 347, 8, 22, 1, 22, 1, 22, 1, 23,
		1, 23, 1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 25, 1,
		25, 3, 25, 363, 8, 25, 1, 25, 1, 25, 1, 25, 3, 25, 368, 8, 25, 1, 25, 1,
		25, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27,
		3, 27, 382, 8, 27, 1, 27, 1, 27, 1, 27, 1, 28, 1, 28, 1, 28, 3, 28, 390,
		8, 28, 1, 28, 1, 28, 1, 29, 1, 29, 1, 29, 1, 29, 1, 30, 1, 30, 1, 30, 1,
		30, 3, 30, 402, 8, 30, 1, 30, 1, 30, 3, 30, 406, 8, 30, 1, 30, 1, 30, 1,
		31, 1, 31, 1, 31, 1, 31, 3, 31, 414, 8, 31, 1, 31, 1, 31, 3, 31, 418, 8,
		31, 1, 31, 1, 31, 1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 426, 8, 32, 1, 32,
		3, 32, 429, 8, 32, 1, 32, 1, 32, 1, 32, 1, 33, 1, 33, 1, 33, 1, 33, 3,
		33, 438, 8, 33, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 35, 1, 35, 1, 35,
		3, 35, 448, 8, 35, 1, 35, 1, 35, 1, 36, 1, 36, 1, 36, 1, 36, 3, 36, 456,
		8, 36, 1, 36, 3, 36, 459, 8, 36, 1, 36, 1, 36, 3, 36, 463, 8, 36, 1, 36,
		1, 36, 3, 36, 467, 8, 36, 1, 36, 1, 36, 1, 37, 1, 37, 1, 37, 1, 37, 1,
		37, 1, 37, 1, 37, 1, 37, 1, 37, 3, 37, 480, 8, 37, 1, 37, 1, 37, 1, 37,
		1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 3, 37, 494,
		8, 37, 1, 37, 1, 37, 3, 37, 498, 8, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1,
		37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37,
		1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1,
		37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 5, 37,
		535, 8, 37, 10, 37, 12, 37, 538, 9, 37, 1, 38, 1, 38, 1, 38, 5, 38, 543,
		8, 38, 10, 38, 12, 38, 546, 9, 38, 1, 39, 1, 39, 1, 39, 3, 39, 551, 8,
		39, 1, 40, 1, 40, 1, 40, 1, 41, 3, 41, 557, 8, 41, 1, 41, 1, 41, 3, 41,
		561, 8, 41, 1, 41, 1, 41, 3, 41, 565, 8, 41, 1, 42, 1, 42, 1, 42, 1, 42,
		5, 42, 571, 8, 42, 10, 42, 12, 42, 574, 9, 42, 1, 42, 3, 42, 577, 8, 42,
		1, 42, 1, 42, 1, 43, 1, 43, 1, 43, 3, 43, 584, 8, 43, 1, 43, 1, 43, 1,
		43, 3, 43, 589, 8, 43, 5, 43, 591, 8, 43, 10, 43, 12, 43, 594, 9, 43, 1,
		43, 3, 43, 597, 8, 43, 3, 43, 599, 8, 43, 1, 43, 1, 43, 1, 44, 1, 44, 1,
		44, 1, 44, 3, 44, 607, 8, 44, 1, 44, 1, 44, 1, 44, 3, 44, 612, 8, 44, 5,
		44, 614, 8, 44, 10, 44, 12, 44, 617, 9, 44, 1, 44, 3, 44, 620, 8, 44, 3,
		44, 622, 8, 44, 1, 44, 1, 44, 1, 45, 1, 45, 5, 45, 628, 8, 45, 10, 45,
		12, 45, 631, 9, 45, 1, 46, 1, 46, 1, 46, 1, 47, 1, 47, 1, 47, 1, 47, 1,
		47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 647, 8, 47, 3, 47,
		649, 8, 47, 1, 47, 1, 47, 1, 48, 1, 48, 3, 48, 655, 8, 48, 1, 48, 1, 48,
		3, 48, 659, 8, 48, 1, 48, 1, 48, 3, 48, 663, 8, 48, 1, 48, 1, 48, 3, 48,
		667, 8, 48, 1, 48, 1, 48, 3, 48, 671, 8, 48, 1, 48, 1, 48, 1, 48, 1, 48,
		1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 681, 8, 48, 3, 48, 683, 8, 48, 1, 49,
		1, 49, 3, 49, 687, 8, 49, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1,
		50, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 3, 51,
		705, 8, 51, 1, 51, 1, 51, 1, 52, 1, 52, 1, 52, 1, 52, 1, 53, 1, 53, 1,
		54, 1, 54, 3, 54, 717, 8, 54, 1, 55, 1, 55, 1, 56, 1, 56, 3, 56, 723, 8,
		56, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 729, 8, 57, 3, 57, 731, 8, 57, 1,
		58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 742,
		8, 58, 1, 58, 1, 58, 1, 58, 3, 58, 747, 8, 58, 1, 59, 1, 59, 1, 59, 5,
		59, 752, 8, 59, 10, 59, 12, 59, 755, 9, 59, 1, 59, 3, 59, 758, 8, 59, 1,
		60, 1, 60, 1, 60, 5, 60, 763, 8, 60, 10, 60, 12, 60, 766, 9, 60, 1, 60,
		3, 60, 769, 8, 60, 1, 61, 1, 61, 1, 61, 5, 61, 774, 8, 61, 10, 61, 12,
		61, 777, 9, 61, 1, 61, 3, 61, 780, 8, 61, 1, 62, 1, 62, 1, 62, 5, 62, 785,
		8, 62, 10, 62, 12, 62, 788, 9, 62, 1, 62, 3, 62, 791, 8, 62, 1, 63, 1,
		63, 1, 63, 5, 63, 796, 8, 63, 10, 63, 12, 63, 799, 9, 63, 1, 63, 3, 63,
		802, 8, 63, 1, 64, 1, 64, 1, 64, 5, 64, 807, 8, 64, 10, 64, 12, 64, 810,
		9, 64, 1, 64, 3, 64, 813, 8, 64, 1, 65, 1, 65, 1, 65, 5, 65, 818, 8, 65,
		10, 65, 12, 65, 821, 9, 65, 1, 65, 3, 65, 824, 8, 65, 1, 65, 0, 1, 74,
		66, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34,
		36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70,
		72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104,
		106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 0, 11,
		1, 0, 25, 26, 2, 0, 30, 30, 32, 32, 2, 0, 66, 66, 84, 84, 2, 0, 70, 70,
		81, 82, 2, 0, 55, 55, 88, 97, 2, 0, 71, 71, 73, 74, 2, 0, 68, 68, 70, 70,
		1, 0, 47, 48, 1, 0, 28, 29, 2, 0, 51, 53, 93, 93, 1, 0, 93, 94, 911, 0,
		133, 1, 0, 0, 0, 2, 143, 1, 0, 0, 0, 4, 185, 1, 0, 0, 0, 6, 187, 1, 0,
		0, 0, 8, 191, 1, 0, 0, 0, 10, 200, 1, 0, 0, 0, 12, 205, 1, 0, 0, 0, 14,
		207, 1, 0, 0, 0, 16, 211, 1, 0, 0, 0, 18, 215, 1, 0, 0, 0, 20, 218, 1,
		0, 0, 0, 22, 221, 1, 0, 0, 0, 24, 224, 1, 0, 0, 0, 26, 238, 1, 0, 0, 0,
		28, 247, 1, 0, 0, 0, 30, 254, 1, 0, 0, 0, 32, 260, 1, 0, 0, 0, 34, 279,
		1, 0, 0, 0, 36, 281, 1, 0, 0, 0, 38, 287, 1, 0, 0, 0, 40, 293, 1, 0, 0,
		0, 42, 341, 1, 0, 0, 0, 44, 343, 1, 0, 0, 0, 46, 350, 1, 0, 0, 0, 48, 354,
		1, 0, 0, 0, 50, 362, 1, 0, 0, 0, 52, 371, 1, 0, 0, 0, 54, 378, 1, 0, 0,
		0, 56, 386, 1, 0, 0, 0, 58, 393, 1, 0, 0, 0, 60, 397, 1, 0, 0, 0, 62, 409,
		1, 0, 0, 0, 64, 421, 1, 0, 0, 0, 66, 433, 1, 0, 0, 0, 68, 441, 1, 0, 0,
		0, 70, 444, 1, 0, 0, 0, 72, 451, 1, 0, 0, 0, 74, 497, 1, 0, 0, 0, 76, 539,
		1, 0, 0, 0, 78, 550, 1, 0, 0, 0, 80, 552, 1, 0, 0, 0, 82, 556, 1, 0, 0,
		0, 84, 566, 1, 0, 0, 0, 86, 580, 1, 0, 0, 0, 88, 602, 1, 0, 0, 0, 90, 625,
		1, 0, 0, 0, 92, 632, 1, 0, 0, 0, 94, 648, 1, 0, 0, 0, 96, 682, 1, 0, 0,
		0, 98, 684, 1, 0, 0, 0, 100, 688, 1, 0, 0, 0, 102, 695, 1, 0, 0, 0, 104,
		708, 1, 0, 0, 0, 106, 712, 1, 0, 0, 0, 108, 716, 1, 0, 0, 0, 110, 718,
		1, 0, 0, 0, 112, 722, 1, 0, 0, 0, 114, 730, 1, 0, 0, 0, 116, 746, 1, 0,
		0, 0, 118, 748, 1, 0, 0, 0, 120, 759, 1, 0, 0, 0, 122, 770, 1, 0, 0, 0,
		124, 781, 1, 0, 0, 0, 126, 792, 1, 0, 0, 0, 128, 803, 1, 0, 0, 0, 130,
		814, 1, 0, 0, 0, 132, 134, 3, 2, 1, 0, 133, 132, 1, 0, 0, 0, 133, 134,
		1, 0, 0, 0, 134, 138, 1, 0, 0, 0, 135, 137, 3, 12, 6, 0, 136, 135, 1, 0,
		0, 0, 137, 140, 1, 0, 0, 0, 138, 136, 1, 0, 0, 0, 138, 139, 1, 0, 0, 0,
		139, 141, 1, 0, 0, 0, 140, 138, 1, 0, 0, 0, 141, 142, 5, 0, 0, 1, 142,
		1, 1, 0, 0, 0, 143, 144, 5, 1, 0, 0, 144, 145, 5, 103, 0, 0, 145, 146,
		5, 63, 0, 0, 146, 3, 1, 0, 0, 0, 147, 186, 3, 10, 5, 0, 148, 150, 3, 6,
		3, 0, 149, 148, 1, 0, 0, 0, 150, 153, 1, 0, 0, 0, 151, 149, 1, 0, 0, 0,
		151, 152, 1, 0, 0, 0, 152, 183, 1, 0, 0, 0, 153, 151, 1, 0, 0, 0, 154,
		184, 3, 48, 24, 0, 155, 184, 3, 66, 33, 0, 156, 184, 3, 36, 18, 0, 157,
		184, 3, 38, 19, 0, 158, 184, 3, 18, 9, 0, 159, 184, 3, 70, 35, 0, 160,
		184, 3, 14, 7, 0, 161, 184, 3, 50, 25, 0, 162, 184, 3, 52, 26, 0, 163,
		184, 3, 20, 10, 0, 164, 184, 3, 60, 30, 0, 165, 184, 3, 72, 36, 0, 166,
		184, 3, 40, 20, 0, 167, 184, 3, 22, 11, 0, 168, 184, 3, 68, 34, 0, 169,
		184, 3, 62, 31, 0, 170, 184, 3, 24, 12, 0, 171, 184, 3, 42, 21, 0, 172,
		184, 3, 64, 32, 0, 173, 184, 3, 26, 13, 0, 174, 184, 3, 16, 8, 0, 175,
		184, 3, 54, 27, 0, 176, 184, 3, 44, 22, 0, 177, 184, 3, 56, 28, 0, 178,
		184, 3, 58, 29, 0, 179, 184, 3, 46, 23, 0, 180, 184, 3, 28, 14, 0, 181,
		184, 3, 32, 16, 0, 182, 184, 3, 30, 15, 0, 183, 154, 1, 0, 0, 0, 183, 155,
		1, 0, 0, 0, 183, 156, 1, 0, 0, 0, 183, 157, 1, 0, 0, 0, 183, 158, 1, 0,
		0, 0, 183, 159, 1, 0, 0, 0, 183, 160, 1, 0, 0, 0, 183, 161, 1, 0, 0, 0,
		183, 162, 1, 0, 0, 0, 183, 163, 1, 0, 0, 0, 183, 164, 1, 0, 0, 0, 183,
		165, 1, 0, 0, 0, 183, 166, 1, 0, 0, 0, 183, 167, 1, 0, 0, 0, 183, 168,
		1, 0, 0, 0, 183, 169, 1, 0, 0, 0, 183, 170, 1, 0, 0, 0, 183, 171, 1, 0,
		0, 0, 183, 172, 1, 0, 0, 0, 183, 173, 1, 0, 0, 0, 183, 174, 1, 0, 0, 0,
		183, 175, 1, 0, 0, 0, 183, 176, 1, 0, 0, 0, 183, 177, 1, 0, 0, 0, 183,
		178, 1, 0, 0, 0, 183, 179, 1, 0, 0, 0, 183, 180, 1, 0, 0, 0, 183, 181,
		1, 0, 0, 0, 183, 182, 1, 0, 0, 0, 184, 186, 1, 0, 0, 0, 185, 147, 1, 0,
		0, 0, 185, 151, 1, 0, 0, 0, 186, 5, 1, 0, 0, 0, 187, 189, 5, 24, 0, 0,
		188, 190, 5, 108, 0, 0, 189, 188, 1, 0, 0, 0, 189, 190, 1, 0, 0, 0, 190,
		7, 1, 0, 0, 0, 191, 195, 5, 58, 0, 0, 192, 194, 3, 12, 6, 0, 193, 192,
		1, 0, 0, 0, 194, 197, 1, 0, 0, 0, 195, 193, 1, 0, 0, 0, 195, 196, 1, 0,
		0, 0, 196, 198, 1, 0, 0, 0, 197, 195, 1, 0, 0, 0, 198, 199, 5, 59, 0, 0,
		199, 9, 1, 0, 0, 0, 200, 201, 5, 23, 0, 0, 201, 202, 5, 108, 0, 0, 202,
		11, 1, 0, 0, 0, 203, 206, 3, 4, 2, 0, 204, 206, 3, 8, 4, 0, 205, 203, 1,
		0, 0, 0, 205, 204, 1, 0, 0, 0, 206, 13, 1, 0, 0, 0, 207, 208, 5, 3, 0,
		0, 208, 209, 5, 105, 0, 0, 209, 210, 5, 63, 0, 0, 210, 15, 1, 0, 0, 0,
		211, 212, 5, 2, 0, 0, 212, 213, 5, 105, 0, 0, 213, 214, 5, 63, 0, 0, 214,
		17, 1, 0, 0, 0, 215, 216, 5, 11, 0, 0, 216, 217, 5, 63, 0, 0, 217, 19,
		1, 0, 0, 0, 218, 219, 5, 12, 0, 0, 219, 220, 5, 63, 0, 0, 220, 21, 1, 0,
		0, 0, 221, 222, 5, 15, 0, 0, 222, 223, 5, 63, 0, 0, 223, 23, 1, 0, 0, 0,
		224, 225, 5, 17, 0, 0, 225, 226, 3, 96, 48, 0, 226, 227, 5, 93, 0, 0, 227,
		234, 5, 19, 0, 0, 228, 235, 3, 84, 42, 0, 229, 230, 5, 56, 0, 0, 230, 231,
		3, 82, 41, 0, 231, 232, 5, 57, 0, 0, 232, 235, 1, 0, 0, 0, 233, 235, 3,
		74, 37, 0, 234, 228, 1, 0, 0, 0, 234, 229, 1, 0, 0, 0, 234, 233, 1, 0,
		0, 0, 235, 236, 1, 0, 0, 0, 236, 237, 3, 12, 6, 0, 237, 25, 1, 0, 0, 0,
		238, 239, 5, 13, 0, 0, 239, 240, 5, 60, 0, 0, 240, 241, 3, 74, 37, 0, 241,
		242, 5, 61, 0, 0, 242, 245, 3, 12, 6, 0, 243, 244, 5, 14, 0, 0, 244, 246,
		3, 12, 6, 0, 245, 243, 1, 0, 0, 0, 245, 246, 1, 0, 0, 0, 246, 27, 1, 0,
		0, 0, 247, 250, 5, 16, 0, 0, 248, 251, 3, 74, 37, 0, 249, 251, 3, 80, 40,
		0, 250, 248, 1, 0, 0, 0, 250, 249, 1, 0, 0, 0, 250, 251, 1, 0, 0, 0, 251,
		252, 1, 0, 0, 0, 252, 253, 5, 63, 0, 0, 253, 29, 1, 0, 0, 0, 254, 255,
		5, 18, 0, 0, 255, 256, 5, 60, 0, 0, 256, 257, 3, 74, 37, 0, 257, 258, 5,
		61, 0, 0, 258, 259, 3, 12, 6, 0, 259, 31, 1, 0, 0, 0, 260, 261, 5, 20,
		0, 0, 261, 262, 5, 60, 0, 0, 262, 263, 3, 74, 37, 0, 263, 264, 5, 61, 0,
		0, 264, 268, 5, 58, 0, 0, 265, 267, 3, 34, 17, 0, 266, 265, 1, 0, 0, 0,
		267, 270, 1, 0, 0, 0, 268, 266, 1, 0, 0, 0, 268, 269, 1, 0, 0, 0, 269,
		271, 1, 0, 0, 0, 270, 268, 1, 0, 0, 0, 271, 272, 5, 59, 0, 0, 272, 33,
		1, 0, 0, 0, 273, 274, 5, 21, 0, 0, 274, 275, 3, 124, 62, 0, 275, 276, 3,
		8, 4, 0, 276, 280, 1, 0, 0, 0, 277, 278, 5, 22, 0, 0, 278, 280, 3, 8, 4,
		0, 279, 273, 1, 0, 0, 0, 279, 277, 1, 0, 0, 0, 280, 35, 1, 0, 0, 0, 281,
		283, 5, 54, 0, 0, 282, 284, 3, 128, 64, 0, 283, 282, 1, 0, 0, 0, 283, 284,
		1, 0, 0, 0, 284, 285, 1, 0, 0, 0, 285, 286, 5, 63, 0, 0, 286, 37, 1, 0,
		0, 0, 287, 289, 5, 9, 0, 0, 288, 290, 3, 104, 52, 0, 289, 288, 1, 0, 0,
		0, 289, 290, 1, 0, 0, 0, 290, 291, 1, 0, 0, 0, 291, 292, 3, 8, 4, 0, 292,
		39, 1, 0, 0, 0, 293, 294, 5, 51, 0, 0, 294, 296, 3, 104, 52, 0, 295, 297,
		3, 128, 64, 0, 296, 295, 1, 0, 0, 0, 296, 297, 1, 0, 0, 0, 297, 298, 1,
		0, 0, 0, 298, 299, 5, 63, 0, 0, 299, 41, 1, 0, 0, 0, 300, 302, 3, 94, 47,
		0, 301, 300, 1, 0, 0, 0, 302, 305, 1, 0, 0, 0, 303, 301, 1, 0, 0, 0, 303,
		304, 1, 0, 0, 0, 304, 306, 1, 0, 0, 0, 305, 303, 1, 0, 0, 0, 306, 312,
		5, 93, 0, 0, 307, 309, 5, 60, 0, 0, 308, 310, 3, 124, 62, 0, 309, 308,
		1, 0, 0, 0, 309, 310, 1, 0, 0, 0, 310, 311, 1, 0, 0, 0, 311, 313, 5, 61,
		0, 0, 312, 307, 1, 0, 0, 0, 312, 313, 1, 0, 0, 0, 313, 315, 1, 0, 0, 0,
		314, 316, 3, 104, 52, 0, 315, 314, 1, 0, 0, 0, 315, 316, 1, 0, 0, 0, 316,
		317, 1, 0, 0, 0, 317, 318, 3, 128, 64, 0, 318, 319, 5, 63, 0, 0, 319, 342,
		1, 0, 0, 0, 320, 322, 3, 94, 47, 0, 321, 320, 1, 0, 0, 0, 322, 325, 1,
		0, 0, 0, 323, 321, 1, 0, 0, 0, 323, 324, 1, 0, 0, 0, 324, 326, 1, 0, 0,
		0, 325, 323, 1, 0, 0, 0, 326, 332, 5, 44, 0, 0, 327, 329, 5, 60, 0, 0,
		328, 330, 3, 124, 62, 0, 329, 328, 1, 0, 0, 0, 329, 330, 1, 0, 0, 0, 330,
		331, 1, 0, 0, 0, 331, 333, 5, 61, 0, 0, 332, 327, 1, 0, 0, 0, 332, 333,
		1, 0, 0, 0, 333, 335, 1, 0, 0, 0, 334, 336, 3, 104, 52, 0, 335, 334, 1,
		0, 0, 0, 335, 336, 1, 0, 0, 0, 336, 338, 1, 0, 0, 0, 337, 339, 3, 128,
		64, 0, 338, 337, 1, 0, 0, 0, 338, 339, 1, 0, 0, 0, 339, 340, 1, 0, 0, 0,
		340, 342, 5, 63, 0, 0, 341, 303, 1, 0, 0, 0, 341, 323, 1, 0, 0, 0, 342,
		43, 1, 0, 0, 0, 343, 346, 3, 80, 40, 0, 344, 345, 5, 67, 0, 0, 345, 347,
		3, 90, 45, 0, 346, 344, 1, 0, 0, 0, 346, 347, 1, 0, 0, 0, 347, 348, 1,
		0, 0, 0, 348, 349, 5, 63, 0, 0, 349, 45, 1, 0, 0, 0, 350, 351, 5, 52, 0,
		0, 351, 352, 3, 112, 56, 0, 352, 353, 5, 63, 0, 0, 353, 47, 1, 0, 0, 0,
		354, 355, 5, 10, 0, 0, 355, 356, 5, 93, 0, 0, 356, 357, 5, 66, 0, 0, 357,
		358, 3, 76, 38, 0, 358, 359, 5, 63, 0, 0, 359, 49, 1, 0, 0, 0, 360, 363,
		3, 96, 48, 0, 361, 363, 3, 100, 50, 0, 362, 360, 1, 0, 0, 0, 362, 361,
		1, 0, 0, 0, 363, 364, 1, 0, 0, 0, 364, 367, 5, 93, 0, 0, 365, 366, 5, 66,
		0, 0, 366, 368, 3, 78, 39, 0, 367, 365, 1, 0, 0, 0, 367, 368, 1, 0, 0,
		0, 368, 369, 1, 0, 0, 0, 369, 370, 5, 63, 0, 0, 370, 51, 1, 0, 0, 0, 371,
		372, 5, 27, 0, 0, 372, 373, 3, 96, 48, 0, 373, 374, 5, 93, 0, 0, 374, 375,
		5, 66, 0, 0, 375, 376, 3, 78, 39, 0, 376, 377, 5, 63, 0, 0, 377, 53, 1,
		0, 0, 0, 378, 381, 7, 0, 0, 0, 379, 382, 3, 96, 48, 0, 380, 382, 3, 100,
		50, 0, 381, 379, 1, 0, 0, 0, 381, 380, 1, 0, 0, 0, 382, 383, 1, 0, 0, 0,
		383, 384, 5, 93, 0, 0, 384, 385, 5, 63, 0, 0, 385, 55, 1, 0, 0, 0, 386,
		387, 7, 1, 0, 0, 387, 389, 5, 93, 0, 0, 388, 390, 3, 104, 52, 0, 389, 388,
		1, 0, 0, 0, 389, 390, 1, 0, 0, 0, 390, 391, 1, 0, 0, 0, 391, 392, 5, 63,
		0, 0, 392, 57, 1, 0, 0, 0, 393, 394, 3, 98, 49, 0, 394, 395, 5, 93, 0,
		0, 395, 396, 5, 63, 0, 0, 396, 59, 1, 0, 0, 0, 397, 398, 5, 4, 0, 0, 398,
		399, 5, 93, 0, 0, 399, 401, 5, 60, 0, 0, 400, 402, 3, 118, 59, 0, 401,
		400, 1, 0, 0, 0, 401, 402, 1, 0, 0, 0, 402, 403, 1, 0, 0, 0, 403, 405,
		5, 61, 0, 0, 404, 406, 3, 92, 46, 0, 405, 404, 1, 0, 0, 0, 405, 406, 1,
		0, 0, 0, 406, 407, 1, 0, 0, 0, 407, 408, 3, 8, 4, 0, 408, 61, 1, 0, 0,
		0, 409, 410, 5, 8, 0, 0, 410, 411, 5, 93, 0, 0, 411, 413, 5, 60, 0, 0,
		412, 414, 3, 130, 65, 0, 413, 412, 1, 0, 0, 0, 413, 414, 1, 0, 0, 0, 414,
		415, 1, 0, 0, 0, 415, 417, 5, 61, 0, 0, 416, 418, 3, 92, 46, 0, 417, 416,
		1, 0, 0, 0, 417, 418, 1, 0, 0, 0, 418, 419, 1, 0, 0, 0, 419, 420, 5, 63,
		0, 0, 420, 63, 1, 0, 0, 0, 421, 422, 5, 7, 0, 0, 422, 428, 5, 93, 0, 0,
		423, 425, 5, 60, 0, 0, 424, 426, 3, 126, 63, 0, 425, 424, 1, 0, 0, 0, 425,
		426, 1, 0, 0, 0, 426, 427, 1, 0, 0, 0, 427, 429, 5, 61, 0, 0, 428, 423,
		1, 0, 0, 0, 428, 429, 1, 0, 0, 0, 429, 430, 1, 0, 0, 0, 430, 431, 3, 126,
		63, 0, 431, 432, 3, 8, 4, 0, 432, 65, 1, 0, 0, 0, 433, 434, 3, 90, 45,
		0, 434, 437, 7, 2, 0, 0, 435, 438, 3, 74, 37, 0, 436, 438, 3, 80, 40, 0,
		437, 435, 1, 0, 0, 0, 437, 436, 1, 0, 0, 0, 438, 439, 1, 0, 0, 0, 439,
		440, 5, 63, 0, 0, 440, 67, 1, 0, 0, 0, 441, 442, 3, 74, 37, 0, 442, 443,
		5, 63, 0, 0, 443, 69, 1, 0, 0, 0, 444, 445, 5, 5, 0, 0, 445, 447, 5, 58,
		0, 0, 446, 448, 5, 113, 0, 0, 447, 446, 1, 0, 0, 0, 447, 448, 1, 0, 0,
		0, 448, 449, 1, 0, 0, 0, 449, 450, 5, 59, 0, 0, 450, 71, 1, 0, 0, 0, 451,
		452, 5, 6, 0, 0, 452, 458, 3, 106, 53, 0, 453, 455, 5, 60, 0, 0, 454, 456,
		3, 120, 60, 0, 455, 454, 1, 0, 0, 0, 455, 456, 1, 0, 0, 0, 456, 457, 1,
		0, 0, 0, 457, 459, 5, 61, 0, 0, 458, 453, 1, 0, 0, 0, 458, 459, 1, 0, 0,
		0, 459, 460, 1, 0, 0, 0, 460, 462, 3, 122, 61, 0, 461, 463, 3, 92, 46,
		0, 462, 461, 1, 0, 0, 0, 462, 463, 1, 0, 0, 0, 463, 464, 1, 0, 0, 0, 464,
		466, 5, 58, 0, 0, 465, 467, 5, 113, 0, 0, 466, 465, 1, 0, 0, 0, 466, 467,
		1, 0, 0, 0, 467, 468, 1, 0, 0, 0, 468, 469, 5, 59, 0, 0, 469, 73, 1, 0,
		0, 0, 470, 471, 6, 37, -1, 0, 471, 472, 5, 60, 0, 0, 472, 473, 3, 74, 37,
		0, 473, 474, 5, 61, 0, 0, 474, 498, 1, 0, 0, 0, 475, 476, 7, 3, 0, 0, 476,
		498, 3, 74, 37, 15, 477, 480, 3, 96, 48, 0, 478, 480, 3, 100, 50, 0, 479,
		477, 1, 0, 0, 0, 479, 478, 1, 0, 0, 0, 480, 481, 1, 0, 0, 0, 481, 482,
		5, 60, 0, 0, 482, 483, 3, 74, 37, 0, 483, 484, 5, 61, 0, 0, 484, 498, 1,
		0, 0, 0, 485, 486, 5, 50, 0, 0, 486, 487, 5, 60, 0, 0, 487, 488, 3, 8,
		4, 0, 488, 489, 5, 61, 0, 0, 489, 498, 1, 0, 0, 0, 490, 491, 5, 93, 0,
		0, 491, 493, 5, 60, 0, 0, 492, 494, 3, 124, 62, 0, 493, 492, 1, 0, 0, 0,
		493, 494, 1, 0, 0, 0, 494, 495, 1, 0, 0, 0, 495, 498, 5, 61, 0, 0, 496,
		498, 7, 4, 0, 0, 497, 470, 1, 0, 0, 0, 497, 475, 1, 0, 0, 0, 497, 479,
		1, 0, 0, 0, 497, 485, 1, 0, 0, 0, 497, 490, 1, 0, 0, 0, 497, 496, 1, 0,
		0, 0, 498, 536, 1, 0, 0, 0, 499, 500, 10, 16, 0, 0, 500, 501, 5, 72, 0,
		0, 501, 535, 3, 74, 37, 16, 502, 503, 10, 14, 0, 0, 503, 504, 7, 5, 0,
		0, 504, 535, 3, 74, 37, 15, 505, 506, 10, 13, 0, 0, 506, 507, 7, 6, 0,
		0, 507, 535, 3, 74, 37, 14, 508, 509, 10, 12, 0, 0, 509, 510, 5, 86, 0,
		0, 510, 535, 3, 74, 37, 13, 511, 512, 10, 11, 0, 0, 512, 513, 5, 85, 0,
		0, 513, 535, 3, 74, 37, 12, 514, 515, 10, 10, 0, 0, 515, 516, 5, 83, 0,
		0, 516, 535, 3, 74, 37, 11, 517, 518, 10, 9, 0, 0, 518, 519, 5, 77, 0,
		0, 519, 535, 3, 74, 37, 10, 520, 521, 10, 8, 0, 0, 521, 522, 5, 79, 0,
		0, 522, 535, 3, 74, 37, 9, 523, 524, 10, 7, 0, 0, 524, 525, 5, 75, 0, 0,
		525, 535, 3, 74, 37, 8, 526, 527, 10, 6, 0, 0, 527, 528, 5, 78, 0, 0, 528,
		535, 3, 74, 37, 7, 529, 530, 10, 5, 0, 0, 530, 531, 5, 76, 0, 0, 531, 535,
		3, 74, 37, 6, 532, 533, 10, 17, 0, 0, 533, 535, 3, 88, 44, 0, 534, 499,
		1, 0, 0, 0, 534, 502, 1, 0, 0, 0, 534, 505, 1, 0, 0, 0, 534, 508, 1, 0,
		0, 0, 534, 511, 1, 0, 0, 0, 534, 514, 1, 0, 0, 0, 534, 517, 1, 0, 0, 0,
		534, 520, 1, 0, 0, 0, 534, 523, 1, 0, 0, 0, 534, 526, 1, 0, 0, 0, 534,
		529, 1, 0, 0, 0, 534, 532, 1, 0, 0, 0, 535, 538, 1, 0, 0, 0, 536, 534,
		1, 0, 0, 0, 536, 537, 1, 0, 0, 0, 537, 75, 1, 0, 0, 0, 538, 536, 1, 0,
		0, 0, 539, 544, 3, 74, 37, 0, 540, 541, 5, 69, 0, 0, 541, 543, 3, 74, 37,
		0, 542, 540, 1, 0, 0, 0, 543, 546, 1, 0, 0, 0, 544, 542, 1, 0, 0, 0, 544,
		545, 1, 0, 0, 0, 545, 77, 1, 0, 0, 0, 546, 544, 1, 0, 0, 0, 547, 551, 3,
		86, 43, 0, 548, 551, 3, 74, 37, 0, 549, 551, 3, 80, 40, 0, 550, 547, 1,
		0, 0, 0, 550, 548, 1, 0, 0, 0, 550, 549, 1, 0, 0, 0, 551, 79, 1, 0, 0,
		0, 552, 553, 5, 53, 0, 0, 553, 554, 3, 112, 56, 0, 554, 81, 1, 0, 0, 0,
		555, 557, 3, 74, 37, 0, 556, 555, 1, 0, 0, 0, 556, 557, 1, 0, 0, 0, 557,
		558, 1, 0, 0, 0, 558, 560, 5, 62, 0, 0, 559, 561, 3, 74, 37, 0, 560, 559,
		1, 0, 0, 0, 560, 561, 1, 0, 0, 0, 561, 564, 1, 0, 0, 0, 562, 563, 5, 62,
		0, 0, 563, 565, 3, 74, 37, 0, 564, 562, 1, 0, 0, 0, 564, 565, 1, 0, 0,
		0, 565, 83, 1, 0, 0, 0, 566, 567, 5, 58, 0, 0, 567, 572, 3, 74, 37, 0,
		568, 569, 5, 65, 0, 0, 569, 571, 3, 74, 37, 0, 570, 568, 1, 0, 0, 0, 571,
		574, 1, 0, 0, 0, 572, 570, 1, 0, 0, 0, 572, 573, 1, 0, 0, 0, 573, 576,
		1, 0, 0, 0, 574, 572, 1, 0, 0, 0, 575, 577, 5, 65, 0, 0, 576, 575, 1, 0,
		0, 0, 576, 577, 1, 0, 0, 0, 577, 578, 1, 0, 0, 0, 578, 579, 5, 59, 0, 0,
		579, 85, 1, 0, 0, 0, 580, 598, 5, 58, 0, 0, 581, 584, 3, 74, 37, 0, 582,
		584, 3, 86, 43, 0, 583, 581, 1, 0, 0, 0, 583, 582, 1, 0, 0, 0, 584, 592,
		1, 0, 0, 0, 585, 588, 5, 65, 0, 0, 586, 589, 3, 74, 37, 0, 587, 589, 3,
		86, 43, 0, 588, 586, 1, 0, 0, 0, 588, 587, 1, 0, 0, 0, 589, 591, 1, 0,
		0, 0, 590, 585, 1, 0, 0, 0, 591, 594, 1, 0, 0, 0, 592, 590, 1, 0, 0, 0,
		592, 593, 1, 0, 0, 0, 593, 596, 1, 0, 0, 0, 594, 592, 1, 0, 0, 0, 595,
		597, 5, 65, 0, 0, 596, 595, 1, 0, 0, 0, 596, 597, 1, 0, 0, 0, 597, 599,
		1, 0, 0, 0, 598, 583, 1, 0, 0, 0, 598, 599, 1, 0, 0, 0, 599, 600, 1, 0,
		0, 0, 600, 601, 5, 59, 0, 0, 601, 87, 1, 0, 0, 0, 602, 621, 5, 56, 0, 0,
		603, 622, 3, 84, 42, 0, 604, 607, 3, 74, 37, 0, 605, 607, 3, 82, 41, 0,
		606, 604, 1, 0, 0, 0, 606, 605, 1, 0, 0, 0, 607, 615, 1, 0, 0, 0, 608,
		611, 5, 65, 0, 0, 609, 612, 3, 74, 37, 0, 610, 612, 3, 82, 41, 0, 611,
		609, 1, 0, 0, 0, 611, 610, 1, 0, 0, 0, 612, 614, 1, 0, 0, 0, 613, 608,
		1, 0, 0, 0, 614, 617, 1, 0, 0, 0, 615, 613, 1, 0, 0, 0, 615, 616, 1, 0,
		0, 0, 616, 619, 1, 0, 0, 0, 617, 615, 1, 0, 0, 0, 618, 620, 5, 65, 0, 0,
		619, 618, 1, 0, 0, 0, 619, 620, 1, 0, 0, 0, 620, 622, 1, 0, 0, 0, 621,
		603, 1, 0, 0, 0, 621, 606, 1, 0, 0, 0, 622, 623, 1, 0, 0, 0, 623, 624,
		5, 57, 0, 0, 624, 89, 1, 0, 0, 0, 625, 629, 5, 93, 0, 0, 626, 628, 3, 88,
		44, 0, 627, 626, 1, 0, 0, 0, 628, 631, 1, 0, 0, 0, 629, 627, 1, 0, 0, 0,
		629, 630, 1, 0, 0, 0, 630, 91, 1, 0, 0, 0, 631, 629, 1, 0, 0, 0, 632, 633,
		5, 67, 0, 0, 633, 634, 3, 96, 48, 0, 634, 93, 1, 0, 0, 0, 635, 649, 5,
		45, 0, 0, 636, 637, 5, 46, 0, 0, 637, 638, 5, 60, 0, 0, 638, 639, 3, 74,
		37, 0, 639, 640, 5, 61, 0, 0, 640, 649, 1, 0, 0, 0, 641, 646, 7, 7, 0,
		0, 642, 643, 5, 60, 0, 0, 643, 644, 3, 74, 37, 0, 644, 645, 5, 61, 0, 0,
		645, 647, 1, 0, 0, 0, 646, 642, 1, 0, 0, 0, 646, 647, 1, 0, 0, 0, 647,
		649, 1, 0, 0, 0, 648, 635, 1, 0, 0, 0, 648, 636, 1, 0, 0, 0, 648, 641,
		1, 0, 0, 0, 649, 650, 1, 0, 0, 0, 650, 651, 5, 80, 0, 0, 651, 95, 1, 0,
		0, 0, 652, 654, 5, 34, 0, 0, 653, 655, 3, 104, 52, 0, 654, 653, 1, 0, 0,
		0, 654, 655, 1, 0, 0, 0, 655, 683, 1, 0, 0, 0, 656, 658, 5, 35, 0, 0, 657,
		659, 3, 104, 52, 0, 658, 657, 1, 0, 0, 0, 658, 659, 1, 0, 0, 0, 659, 683,
		1, 0, 0, 0, 660, 662, 5, 36, 0, 0, 661, 663, 3, 104, 52, 0, 662, 661, 1,
		0, 0, 0, 662, 663, 1, 0, 0, 0, 663, 683, 1, 0, 0, 0, 664, 666, 5, 37, 0,
		0, 665, 667, 3, 104, 52, 0, 666, 665, 1, 0, 0, 0, 666, 667, 1, 0, 0, 0,
		667, 683, 1, 0, 0, 0, 668, 670, 5, 38, 0, 0, 669, 671, 3, 104, 52, 0, 670,
		669, 1, 0, 0, 0, 670, 671, 1, 0, 0, 0, 671, 683, 1, 0, 0, 0, 672, 683,
		5, 33, 0, 0, 673, 683, 5, 42, 0, 0, 674, 683, 5, 43, 0, 0, 675, 680, 5,
		39, 0, 0, 676, 677, 5, 56, 0, 0, 677, 678, 3, 96, 48, 0, 678, 679, 5, 57,
		0, 0, 679, 681, 1, 0, 0, 0, 680, 676, 1, 0, 0, 0, 680, 681, 1, 0, 0, 0,
		681, 683, 1, 0, 0, 0, 682, 652, 1, 0, 0, 0, 682, 656, 1, 0, 0, 0, 682,
		660, 1, 0, 0, 0, 682, 664, 1, 0, 0, 0, 682, 668, 1, 0, 0, 0, 682, 672,
		1, 0, 0, 0, 682, 673, 1, 0, 0, 0, 682, 674, 1, 0, 0, 0, 682, 675, 1, 0,
		0, 0, 683, 97, 1, 0, 0, 0, 684, 686, 5, 31, 0, 0, 685, 687, 3, 104, 52,
		0, 686, 685, 1, 0, 0, 0, 686, 687, 1, 0, 0, 0, 687, 99, 1, 0, 0, 0, 688,
		689, 5, 40, 0, 0, 689, 690, 5, 56, 0, 0, 690, 691, 3, 96, 48, 0, 691, 692,
		5, 65, 0, 0, 692, 693, 3, 124, 62, 0, 693, 694, 5, 57, 0, 0, 694, 101,
		1, 0, 0, 0, 695, 696, 7, 8, 0, 0, 696, 697, 5, 40, 0, 0, 697, 698, 5, 56,
		0, 0, 698, 699, 3, 96, 48, 0, 699, 704, 5, 65, 0, 0, 700, 705, 3, 124,
		62, 0, 701, 702, 5, 49, 0, 0, 702, 703, 5, 66, 0, 0, 703, 705, 3, 74, 37,
		0, 704, 700, 1, 0, 0, 0, 704, 701, 1, 0, 0, 0, 705, 706, 1, 0, 0, 0, 706,
		707, 5, 57, 0, 0, 707, 103, 1, 0, 0, 0, 708, 709, 5, 56, 0, 0, 709, 710,
		3, 74, 37, 0, 710, 711, 5, 57, 0, 0, 711, 105, 1, 0, 0, 0, 712, 713, 7,
		9, 0, 0, 713, 107, 1, 0, 0, 0, 714, 717, 3, 74, 37, 0, 715, 717, 3, 116,
		58, 0, 716, 714, 1, 0, 0, 0, 716, 715, 1, 0, 0, 0, 717, 109, 1, 0, 0, 0,
		718, 719, 7, 10, 0, 0, 719, 111, 1, 0, 0, 0, 720, 723, 3, 90, 45, 0, 721,
		723, 5, 94, 0, 0, 722, 720, 1, 0, 0, 0, 722, 721, 1, 0, 0, 0, 723, 113,
		1, 0, 0, 0, 724, 731, 3, 96, 48, 0, 725, 731, 3, 102, 51, 0, 726, 728,
		5, 32, 0, 0, 727, 729, 3, 104, 52, 0, 728, 727, 1, 0, 0, 0, 728, 729, 1,
		0, 0, 0, 729, 731, 1, 0, 0, 0, 730, 724, 1, 0, 0, 0, 730, 725, 1, 0, 0,
		0, 730, 726, 1, 0, 0, 0, 731, 115, 1, 0, 0, 0, 732, 733, 3, 96, 48, 0,
		733, 734, 5, 93, 0, 0, 734, 747, 1, 0, 0, 0, 735, 736, 3, 98, 49, 0, 736,
		737, 5, 93, 0, 0, 737, 747, 1, 0, 0, 0, 738, 739, 7, 1, 0, 0, 739, 741,
		5, 93, 0, 0, 740, 742, 3, 104, 52, 0, 741, 740, 1, 0, 0, 0, 741, 742, 1,
		0, 0, 0, 742, 747, 1, 0, 0, 0, 743, 744, 3, 102, 51, 0, 744, 745, 5, 93,
		0, 0, 745, 747, 1, 0, 0, 0, 746, 732, 1, 0, 0, 0, 746, 735, 1, 0, 0, 0,
		746, 738, 1, 0, 0, 0, 746, 743, 1, 0, 0, 0, 747, 117, 1, 0, 0, 0, 748,
		753, 3, 116, 58, 0, 749, 750, 5, 65, 0, 0, 750, 752, 3, 116, 58, 0, 751,
		749, 1, 0, 0, 0, 752, 755, 1, 0, 0, 0, 753, 751, 1, 0, 0, 0, 753, 754,
		1, 0, 0, 0, 754, 757, 1, 0, 0, 0, 755, 753, 1, 0, 0, 0, 756, 758, 5, 65,
		0, 0, 757, 756, 1, 0, 0, 0, 757, 758, 1, 0, 0, 0, 758, 119, 1, 0, 0, 0,
		759, 764, 3, 108, 54, 0, 760, 761, 5, 65, 0, 0, 761, 763, 3, 108, 54, 0,
		762, 760, 1, 0, 0, 0, 763, 766, 1, 0, 0, 0, 764, 762, 1, 0, 0, 0, 764,
		765, 1, 0, 0, 0, 765, 768, 1, 0, 0, 0, 766, 764, 1, 0, 0, 0, 767, 769,
		5, 65, 0, 0, 768, 767, 1, 0, 0, 0, 768, 769, 1, 0, 0, 0, 769, 121, 1, 0,
		0, 0, 770, 775, 3, 110, 55, 0, 771, 772, 5, 65, 0, 0, 772, 774, 3, 110,
		55, 0, 773, 771, 1, 0, 0, 0, 774, 777, 1, 0, 0, 0, 775, 773, 1, 0, 0, 0,
		775, 776, 1, 0, 0, 0, 776, 779, 1, 0, 0, 0, 777, 775, 1, 0, 0, 0, 778,
		780, 5, 65, 0, 0, 779, 778, 1, 0, 0, 0, 779, 780, 1, 0, 0, 0, 780, 123,
		1, 0, 0, 0, 781, 786, 3, 74, 37, 0, 782, 783, 5, 65, 0, 0, 783, 785, 3,
		74, 37, 0, 784, 782, 1, 0, 0, 0, 785, 788, 1, 0, 0, 0, 786, 784, 1, 0,
		0, 0, 786, 787, 1, 0, 0, 0, 787, 790, 1, 0, 0, 0, 788, 786, 1, 0, 0, 0,
		789, 791, 5, 65, 0, 0, 790, 789, 1, 0, 0, 0, 790, 791, 1, 0, 0, 0, 791,
		125, 1, 0, 0, 0, 792, 797, 5, 93, 0, 0, 793, 794, 5, 65, 0, 0, 794, 796,
		5, 93, 0, 0, 795, 793, 1, 0, 0, 0, 796, 799, 1, 0, 0, 0, 797, 795, 1, 0,
		0, 0, 797, 798, 1, 0, 0, 0, 798, 801, 1, 0, 0, 0, 799, 797, 1, 0, 0, 0,
		800, 802, 5, 65, 0, 0, 801, 800, 1, 0, 0, 0, 801, 802, 1, 0, 0, 0, 802,
		127, 1, 0, 0, 0, 803, 808, 3, 112, 56, 0, 804, 805, 5, 65, 0, 0, 805, 807,
		3, 112, 56, 0, 806, 804, 1, 0, 0, 0, 807, 810, 1, 0, 0, 0, 808, 806, 1,
		0, 0, 0, 808, 809, 1, 0, 0, 0, 809, 812, 1, 0, 0, 0, 810, 808, 1, 0, 0,
		0, 811, 813, 5, 65, 0, 0, 812, 811, 1, 0, 0, 0, 812, 813, 1, 0, 0, 0, 813,
		129, 1, 0, 0, 0, 814, 819, 3, 114, 57, 0, 815, 816, 5, 65, 0, 0, 816, 818,
		3, 114, 57, 0, 817, 815, 1, 0, 0, 0, 818, 821, 1, 0, 0, 0, 819, 817, 1,
		0, 0, 0, 819, 820, 1, 0, 0, 0, 820, 823, 1, 0, 0, 0, 821, 819, 1, 0, 0,
		0, 822, 824, 5, 65, 0, 0, 823, 822, 1, 0, 0, 0, 823, 824, 1, 0, 0, 0, 824,
		131, 1, 0, 0, 0, 97, 133, 138, 151, 183, 185, 189, 195, 205, 234, 245,
		250, 268, 279, 283, 289, 296, 303, 309, 312, 315, 323, 329, 332, 335, 338,
		341, 346, 362, 367, 381, 389, 401, 405, 413, 417, 425, 428, 437, 447, 455,
		458, 462, 466, 479, 493, 497, 534, 536, 544, 550, 556, 560, 564, 572, 576,
		583, 588, 592, 596, 598, 606, 611, 615, 619, 621, 629, 646, 648, 654, 658,
		662, 666, 670, 680, 682, 686, 704, 716, 722, 728, 730, 741, 746, 753, 757,
		764, 768, 775, 779, 786, 790, 797, 801, 808, 812, 819, 823,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// qasm3ParserInit initializes any static state used to implement qasm3Parser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// Newqasm3Parser(). You can call this function if you wish to initialize the static state ahead
// of time.
func Qasm3ParserInit() {
	staticData := &Qasm3ParserParserStaticData
	staticData.once.Do(qasm3parserParserInit)
}

// Newqasm3Parser produces a new parser instance for the optional input antlr.TokenStream.
func Newqasm3Parser(input antlr.TokenStream) *qasm3Parser {
	Qasm3ParserInit()
	this := new(qasm3Parser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &Qasm3ParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "qasm3Parser.g4"

	return this
}

// qasm3Parser tokens.
const (
	qasm3ParserEOF                          = antlr.TokenEOF
	qasm3ParserOPENQASM                     = 1
	qasm3ParserINCLUDE                      = 2
	qasm3ParserDEFCALGRAMMAR                = 3
	qasm3ParserDEF                          = 4
	qasm3ParserCAL                          = 5
	qasm3ParserDEFCAL                       = 6
	qasm3ParserGATE                         = 7
	qasm3ParserEXTERN                       = 8
	qasm3ParserBOX                          = 9
	qasm3ParserLET                          = 10
	qasm3ParserBREAK                        = 11
	qasm3ParserCONTINUE                     = 12
	qasm3ParserIF                           = 13
	qasm3ParserELSE                         = 14
	qasm3ParserEND                          = 15
	qasm3ParserRETURN                       = 16
	qasm3ParserFOR                          = 17
	qasm3ParserWHILE                        = 18
	qasm3ParserIN                           = 19
	qasm3ParserSWITCH                       = 20
	qasm3ParserCASE                         = 21
	qasm3ParserDEFAULT                      = 22
	qasm3ParserPRAGMA                       = 23
	qasm3ParserAnnotationKeyword            = 24
	qasm3ParserINPUT                        = 25
	qasm3ParserOUTPUT                       = 26
	qasm3ParserCONST                        = 27
	qasm3ParserREADONLY                     = 28
	qasm3ParserMUTABLE                      = 29
	qasm3ParserQREG                         = 30
	qasm3ParserQUBIT                        = 31
	qasm3ParserCREG                         = 32
	qasm3ParserBOOL                         = 33
	qasm3ParserBIT                          = 34
	qasm3ParserINT                          = 35
	qasm3ParserUINT                         = 36
	qasm3ParserFLOAT                        = 37
	qasm3ParserANGLE                        = 38
	qasm3ParserCOMPLEX                      = 39
	qasm3ParserARRAY                        = 40
	qasm3ParserVOID                         = 41
	qasm3ParserDURATION                     = 42
	qasm3ParserSTRETCH                      = 43
	qasm3ParserGPHASE                       = 44
	qasm3ParserINV                          = 45
	qasm3ParserPOW                          = 46
	qasm3ParserCTRL                         = 47
	qasm3ParserNEGCTRL                      = 48
	qasm3ParserDIM                          = 49
	qasm3ParserDURATIONOF                   = 50
	qasm3ParserDELAY                        = 51
	qasm3ParserRESET                        = 52
	qasm3ParserMEASURE                      = 53
	qasm3ParserBARRIER                      = 54
	qasm3ParserBooleanLiteral               = 55
	qasm3ParserLBRACKET                     = 56
	qasm3ParserRBRACKET                     = 57
	qasm3ParserLBRACE                       = 58
	qasm3ParserRBRACE                       = 59
	qasm3ParserLPAREN                       = 60
	qasm3ParserRPAREN                       = 61
	qasm3ParserCOLON                        = 62
	qasm3ParserSEMICOLON                    = 63
	qasm3ParserDOT                          = 64
	qasm3ParserCOMMA                        = 65
	qasm3ParserEQUALS                       = 66
	qasm3ParserARROW                        = 67
	qasm3ParserPLUS                         = 68
	qasm3ParserDOUBLE_PLUS                  = 69
	qasm3ParserMINUS                        = 70
	qasm3ParserASTERISK                     = 71
	qasm3ParserDOUBLE_ASTERISK              = 72
	qasm3ParserSLASH                        = 73
	qasm3ParserPERCENT                      = 74
	qasm3ParserPIPE                         = 75
	qasm3ParserDOUBLE_PIPE                  = 76
	qasm3ParserAMPERSAND                    = 77
	qasm3ParserDOUBLE_AMPERSAND             = 78
	qasm3ParserCARET                        = 79
	qasm3ParserAT                           = 80
	qasm3ParserTILDE                        = 81
	qasm3ParserEXCLAMATION_POINT            = 82
	qasm3ParserEqualityOperator             = 83
	qasm3ParserCompoundAssignmentOperator   = 84
	qasm3ParserComparisonOperator           = 85
	qasm3ParserBitshiftOperator             = 86
	qasm3ParserIMAG                         = 87
	qasm3ParserImaginaryLiteral             = 88
	qasm3ParserBinaryIntegerLiteral         = 89
	qasm3ParserOctalIntegerLiteral          = 90
	qasm3ParserDecimalIntegerLiteral        = 91
	qasm3ParserHexIntegerLiteral            = 92
	qasm3ParserIdentifier                   = 93
	qasm3ParserHardwareQubit                = 94
	qasm3ParserFloatLiteral                 = 95
	qasm3ParserTimingLiteral                = 96
	qasm3ParserBitstringLiteral             = 97
	qasm3ParserWhitespace                   = 98
	qasm3ParserNewline                      = 99
	qasm3ParserLineComment                  = 100
	qasm3ParserBlockComment                 = 101
	qasm3ParserVERSION_IDENTIFER_WHITESPACE = 102
	qasm3ParserVersionSpecifier             = 103
	qasm3ParserARBITRARY_STRING_WHITESPACE  = 104
	qasm3ParserStringLiteral                = 105
	qasm3ParserEAT_INITIAL_SPACE            = 106
	qasm3ParserEAT_LINE_END                 = 107
	qasm3ParserRemainingLineContent         = 108
	qasm3ParserCAL_PRELUDE_WHITESPACE       = 109
	qasm3ParserCAL_PRELUDE_COMMENT          = 110
	qasm3ParserDEFCAL_PRELUDE_WHITESPACE    = 111
	qasm3ParserDEFCAL_PRELUDE_COMMENT       = 112
	qasm3ParserCalibrationBlock             = 113
)

// qasm3Parser rules.
const (
	qasm3ParserRULE_program                         = 0
	qasm3ParserRULE_version                         = 1
	qasm3ParserRULE_statement                       = 2
	qasm3ParserRULE_annotation                      = 3
	qasm3ParserRULE_scope                           = 4
	qasm3ParserRULE_pragma                          = 5
	qasm3ParserRULE_statementOrScope                = 6
	qasm3ParserRULE_calibrationGrammarStatement     = 7
	qasm3ParserRULE_includeStatement                = 8
	qasm3ParserRULE_breakStatement                  = 9
	qasm3ParserRULE_continueStatement               = 10
	qasm3ParserRULE_endStatement                    = 11
	qasm3ParserRULE_forStatement                    = 12
	qasm3ParserRULE_ifStatement                     = 13
	qasm3ParserRULE_returnStatement                 = 14
	qasm3ParserRULE_whileStatement                  = 15
	qasm3ParserRULE_switchStatement                 = 16
	qasm3ParserRULE_switchCaseItem                  = 17
	qasm3ParserRULE_barrierStatement                = 18
	qasm3ParserRULE_boxStatement                    = 19
	qasm3ParserRULE_delayStatement                  = 20
	qasm3ParserRULE_gateCallStatement               = 21
	qasm3ParserRULE_measureArrowAssignmentStatement = 22
	qasm3ParserRULE_resetStatement                  = 23
	qasm3ParserRULE_aliasDeclarationStatement       = 24
	qasm3ParserRULE_classicalDeclarationStatement   = 25
	qasm3ParserRULE_constDeclarationStatement       = 26
	qasm3ParserRULE_ioDeclarationStatement          = 27
	qasm3ParserRULE_oldStyleDeclarationStatement    = 28
	qasm3ParserRULE_quantumDeclarationStatement     = 29
	qasm3ParserRULE_defStatement                    = 30
	qasm3ParserRULE_externStatement                 = 31
	qasm3ParserRULE_gateStatement                   = 32
	qasm3ParserRULE_assignmentStatement             = 33
	qasm3ParserRULE_expressionStatement             = 34
	qasm3ParserRULE_calStatement                    = 35
	qasm3ParserRULE_defcalStatement                 = 36
	qasm3ParserRULE_expression                      = 37
	qasm3ParserRULE_aliasExpression                 = 38
	qasm3ParserRULE_declarationExpression           = 39
	qasm3ParserRULE_measureExpression               = 40
	qasm3ParserRULE_rangeExpression                 = 41
	qasm3ParserRULE_setExpression                   = 42
	qasm3ParserRULE_arrayLiteral                    = 43
	qasm3ParserRULE_indexOperator                   = 44
	qasm3ParserRULE_indexedIdentifier               = 45
	qasm3ParserRULE_returnSignature                 = 46
	qasm3ParserRULE_gateModifier                    = 47
	qasm3ParserRULE_scalarType                      = 48
	qasm3ParserRULE_qubitType                       = 49
	qasm3ParserRULE_arrayType                       = 50
	qasm3ParserRULE_arrayReferenceType              = 51
	qasm3ParserRULE_designator                      = 52
	qasm3ParserRULE_defcalTarget                    = 53
	qasm3ParserRULE_defcalArgumentDefinition        = 54
	qasm3ParserRULE_defcalOperand                   = 55
	qasm3ParserRULE_gateOperand                     = 56
	qasm3ParserRULE_externArgument                  = 57
	qasm3ParserRULE_argumentDefinition              = 58
	qasm3ParserRULE_argumentDefinitionList          = 59
	qasm3ParserRULE_defcalArgumentDefinitionList    = 60
	qasm3ParserRULE_defcalOperandList               = 61
	qasm3ParserRULE_expressionList                  = 62
	qasm3ParserRULE_identifierList                  = 63
	qasm3ParserRULE_gateOperandList                 = 64
	qasm3ParserRULE_externArgumentList              = 65
)

// IProgramContext is an interface to support dynamic dispatch.
type IProgramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	Version() IVersionContext
	AllStatementOrScope() []IStatementOrScopeContext
	StatementOrScope(i int) IStatementOrScopeContext

	// IsProgramContext differentiates from other interfaces.
	IsProgramContext()
}

type ProgramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramContext() *ProgramContext {
	var p = new(ProgramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_program
	return p
}

func InitEmptyProgramContext(p *ProgramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_program
}

func (*ProgramContext) IsProgramContext() {}

func NewProgramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramContext {
	var p = new(ProgramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_program

	return p
}

func (s *ProgramContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramContext) EOF() antlr.TerminalNode {
	return s.GetToken(qasm3ParserEOF, 0)
}

func (s *ProgramContext) Version() IVersionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVersionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVersionContext)
}

func (s *ProgramContext) AllStatementOrScope() []IStatementOrScopeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementOrScopeContext); ok {
			len++
		}
	}

	tst := make([]IStatementOrScopeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementOrScopeContext); ok {
			tst[i] = t.(IStatementOrScopeContext)
			i++
		}
	}

	return tst
}

func (s *ProgramContext) StatementOrScope(i int) IStatementOrScopeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementOrScopeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementOrScopeContext)
}

func (s *ProgramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterProgram(s)
	}
}

func (s *ProgramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitProgram(s)
	}
}

func (s *ProgramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitProgram(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) Program() (localctx IProgramContext) {
	localctx = NewProgramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, qasm3ParserRULE_program)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(133)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserOPENQASM {
		{
			p.SetState(132)
			p.Version()
		}

	}
	p.SetState(138)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1512644325007671292) != 0) || ((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&268179457) != 0) {
		{
			p.SetState(135)
			p.StatementOrScope()
		}

		p.SetState(140)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(141)
		p.Match(qasm3ParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVersionContext is an interface to support dynamic dispatch.
type IVersionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPENQASM() antlr.TerminalNode
	VersionSpecifier() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode

	// IsVersionContext differentiates from other interfaces.
	IsVersionContext()
}

type VersionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVersionContext() *VersionContext {
	var p = new(VersionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_version
	return p
}

func InitEmptyVersionContext(p *VersionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_version
}

func (*VersionContext) IsVersionContext() {}

func NewVersionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VersionContext {
	var p = new(VersionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_version

	return p
}

func (s *VersionContext) GetParser() antlr.Parser { return s.parser }

func (s *VersionContext) OPENQASM() antlr.TerminalNode {
	return s.GetToken(qasm3ParserOPENQASM, 0)
}

func (s *VersionContext) VersionSpecifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserVersionSpecifier, 0)
}

func (s *VersionContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *VersionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VersionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VersionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterVersion(s)
	}
}

func (s *VersionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitVersion(s)
	}
}

func (s *VersionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitVersion(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) Version() (localctx IVersionContext) {
	localctx = NewVersionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, qasm3ParserRULE_version)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(143)
		p.Match(qasm3ParserOPENQASM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(144)
		p.Match(qasm3ParserVersionSpecifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(145)
		p.Match(qasm3ParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Pragma() IPragmaContext
	AliasDeclarationStatement() IAliasDeclarationStatementContext
	AssignmentStatement() IAssignmentStatementContext
	BarrierStatement() IBarrierStatementContext
	BoxStatement() IBoxStatementContext
	BreakStatement() IBreakStatementContext
	CalStatement() ICalStatementContext
	CalibrationGrammarStatement() ICalibrationGrammarStatementContext
	ClassicalDeclarationStatement() IClassicalDeclarationStatementContext
	ConstDeclarationStatement() IConstDeclarationStatementContext
	ContinueStatement() IContinueStatementContext
	DefStatement() IDefStatementContext
	DefcalStatement() IDefcalStatementContext
	DelayStatement() IDelayStatementContext
	EndStatement() IEndStatementContext
	ExpressionStatement() IExpressionStatementContext
	ExternStatement() IExternStatementContext
	ForStatement() IForStatementContext
	GateCallStatement() IGateCallStatementContext
	GateStatement() IGateStatementContext
	IfStatement() IIfStatementContext
	IncludeStatement() IIncludeStatementContext
	IoDeclarationStatement() IIoDeclarationStatementContext
	MeasureArrowAssignmentStatement() IMeasureArrowAssignmentStatementContext
	OldStyleDeclarationStatement() IOldStyleDeclarationStatementContext
	QuantumDeclarationStatement() IQuantumDeclarationStatementContext
	ResetStatement() IResetStatementContext
	ReturnStatement() IReturnStatementContext
	SwitchStatement() ISwitchStatementContext
	WhileStatement() IWhileStatementContext
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Pragma() IPragmaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPragmaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPragmaContext)
}

func (s *StatementContext) AliasDeclarationStatement() IAliasDeclarationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasDeclarationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasDeclarationStatementContext)
}

func (s *StatementContext) AssignmentStatement() IAssignmentStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentStatementContext)
}

func (s *StatementContext) BarrierStatement() IBarrierStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBarrierStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBarrierStatementContext)
}

func (s *StatementContext) BoxStatement() IBoxStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoxStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoxStatementContext)
}

func (s *StatementContext) BreakStatement() IBreakStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStatementContext)
}

func (s *StatementContext) CalStatement() ICalStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICalStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICalStatementContext)
}

func (s *StatementContext) CalibrationGrammarStatement() ICalibrationGrammarStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICalibrationGrammarStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICalibrationGrammarStatementContext)
}

func (s *StatementContext) ClassicalDeclarationStatement() IClassicalDeclarationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassicalDeclarationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassicalDeclarationStatementContext)
}

func (s *StatementContext) ConstDeclarationStatement() IConstDeclarationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstDeclarationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstDeclarationStatementContext)
}

func (s *StatementContext) ContinueStatement() IContinueStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *StatementContext) DefStatement() IDefStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefStatementContext)
}

func (s *StatementContext) DefcalStatement() IDefcalStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefcalStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefcalStatementContext)
}

func (s *StatementContext) DelayStatement() IDelayStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelayStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelayStatementContext)
}

func (s *StatementContext) EndStatement() IEndStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEndStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEndStatementContext)
}

func (s *StatementContext) ExpressionStatement() IExpressionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *StatementContext) ExternStatement() IExternStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternStatementContext)
}

func (s *StatementContext) ForStatement() IForStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *StatementContext) GateCallStatement() IGateCallStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGateCallStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGateCallStatementContext)
}

func (s *StatementContext) GateStatement() IGateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGateStatementContext)
}

func (s *StatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *StatementContext) IncludeStatement() IIncludeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIncludeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIncludeStatementContext)
}

func (s *StatementContext) IoDeclarationStatement() IIoDeclarationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIoDeclarationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIoDeclarationStatementContext)
}

func (s *StatementContext) MeasureArrowAssignmentStatement() IMeasureArrowAssignmentStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMeasureArrowAssignmentStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMeasureArrowAssignmentStatementContext)
}

func (s *StatementContext) OldStyleDeclarationStatement() IOldStyleDeclarationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOldStyleDeclarationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOldStyleDeclarationStatementContext)
}

func (s *StatementContext) QuantumDeclarationStatement() IQuantumDeclarationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuantumDeclarationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuantumDeclarationStatementContext)
}

func (s *StatementContext) ResetStatement() IResetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResetStatementContext)
}

func (s *StatementContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *StatementContext) SwitchStatement() ISwitchStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchStatementContext)
}

func (s *StatementContext) WhileStatement() IWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *StatementContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *StatementContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, qasm3ParserRULE_statement)
	var _la int

	p.SetState(185)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserPRAGMA:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(147)
			p.Pragma()
		}

	case qasm3ParserINCLUDE, qasm3ParserDEFCALGRAMMAR, qasm3ParserDEF, qasm3ParserCAL, qasm3ParserDEFCAL, qasm3ParserGATE, qasm3ParserEXTERN, qasm3ParserBOX, qasm3ParserLET, qasm3ParserBREAK, qasm3ParserCONTINUE, qasm3ParserIF, qasm3ParserEND, qasm3ParserRETURN, qasm3ParserFOR, qasm3ParserWHILE, qasm3ParserSWITCH, qasm3ParserAnnotationKeyword, qasm3ParserINPUT, qasm3ParserOUTPUT, qasm3ParserCONST, qasm3ParserQREG, qasm3ParserQUBIT, qasm3ParserCREG, qasm3ParserBOOL, qasm3ParserBIT, qasm3ParserINT, qasm3ParserUINT, qasm3ParserFLOAT, qasm3ParserANGLE, qasm3ParserCOMPLEX, qasm3ParserARRAY, qasm3ParserDURATION, qasm3ParserSTRETCH, qasm3ParserGPHASE, qasm3ParserINV, qasm3ParserPOW, qasm3ParserCTRL, qasm3ParserNEGCTRL, qasm3ParserDURATIONOF, qasm3ParserDELAY, qasm3ParserRESET, qasm3ParserMEASURE, qasm3ParserBARRIER, qasm3ParserBooleanLiteral, qasm3ParserLPAREN, qasm3ParserMINUS, qasm3ParserTILDE, qasm3ParserEXCLAMATION_POINT, qasm3ParserImaginaryLiteral, qasm3ParserBinaryIntegerLiteral, qasm3ParserOctalIntegerLiteral, qasm3ParserDecimalIntegerLiteral, qasm3ParserHexIntegerLiteral, qasm3ParserIdentifier, qasm3ParserHardwareQubit, qasm3ParserFloatLiteral, qasm3ParserTimingLiteral, qasm3ParserBitstringLiteral:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(151)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == qasm3ParserAnnotationKeyword {
			{
				p.SetState(148)
				p.Annotation()
			}

			p.SetState(153)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(183)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(154)
				p.AliasDeclarationStatement()
			}

		case 2:
			{
				p.SetState(155)
				p.AssignmentStatement()
			}

		case 3:
			{
				p.SetState(156)
				p.BarrierStatement()
			}

		case 4:
			{
				p.SetState(157)
				p.BoxStatement()
			}

		case 5:
			{
				p.SetState(158)
				p.BreakStatement()
			}

		case 6:
			{
				p.SetState(159)
				p.CalStatement()
			}

		case 7:
			{
				p.SetState(160)
				p.CalibrationGrammarStatement()
			}

		case 8:
			{
				p.SetState(161)
				p.ClassicalDeclarationStatement()
			}

		case 9:
			{
				p.SetState(162)
				p.ConstDeclarationStatement()
			}

		case 10:
			{
				p.SetState(163)
				p.ContinueStatement()
			}

		case 11:
			{
				p.SetState(164)
				p.DefStatement()
			}

		case 12:
			{
				p.SetState(165)
				p.DefcalStatement()
			}

		case 13:
			{
				p.SetState(166)
				p.DelayStatement()
			}

		case 14:
			{
				p.SetState(167)
				p.EndStatement()
			}

		case 15:
			{
				p.SetState(168)
				p.ExpressionStatement()
			}

		case 16:
			{
				p.SetState(169)
				p.ExternStatement()
			}

		case 17:
			{
				p.SetState(170)
				p.ForStatement()
			}

		case 18:
			{
				p.SetState(171)
				p.GateCallStatement()
			}

		case 19:
			{
				p.SetState(172)
				p.GateStatement()
			}

		case 20:
			{
				p.SetState(173)
				p.IfStatement()
			}

		case 21:
			{
				p.SetState(174)
				p.IncludeStatement()
			}

		case 22:
			{
				p.SetState(175)
				p.IoDeclarationStatement()
			}

		case 23:
			{
				p.SetState(176)
				p.MeasureArrowAssignmentStatement()
			}

		case 24:
			{
				p.SetState(177)
				p.OldStyleDeclarationStatement()
			}

		case 25:
			{
				p.SetState(178)
				p.QuantumDeclarationStatement()
			}

		case 26:
			{
				p.SetState(179)
				p.ResetStatement()
			}

		case 27:
			{
				p.SetState(180)
				p.ReturnStatement()
			}

		case 28:
			{
				p.SetState(181)
				p.SwitchStatement()
			}

		case 29:
			{
				p.SetState(182)
				p.WhileStatement()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnotationContext is an interface to support dynamic dispatch.
type IAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AnnotationKeyword() antlr.TerminalNode
	RemainingLineContent() antlr.TerminalNode

	// IsAnnotationContext differentiates from other interfaces.
	IsAnnotationContext()
}

type AnnotationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationContext() *AnnotationContext {
	var p = new(AnnotationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_annotation
	return p
}

func InitEmptyAnnotationContext(p *AnnotationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_annotation
}

func (*AnnotationContext) IsAnnotationContext() {}

func NewAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationContext {
	var p = new(AnnotationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_annotation

	return p
}

func (s *AnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationContext) AnnotationKeyword() antlr.TerminalNode {
	return s.GetToken(qasm3ParserAnnotationKeyword, 0)
}

func (s *AnnotationContext) RemainingLineContent() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRemainingLineContent, 0)
}

func (s *AnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterAnnotation(s)
	}
}

func (s *AnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitAnnotation(s)
	}
}

func (s *AnnotationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitAnnotation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) Annotation() (localctx IAnnotationContext) {
	localctx = NewAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, qasm3ParserRULE_annotation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(187)
		p.Match(qasm3ParserAnnotationKeyword)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(189)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserRemainingLineContent {
		{
			p.SetState(188)
			p.Match(qasm3ParserRemainingLineContent)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScopeContext is an interface to support dynamic dispatch.
type IScopeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllStatementOrScope() []IStatementOrScopeContext
	StatementOrScope(i int) IStatementOrScopeContext

	// IsScopeContext differentiates from other interfaces.
	IsScopeContext()
}

type ScopeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScopeContext() *ScopeContext {
	var p = new(ScopeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_scope
	return p
}

func InitEmptyScopeContext(p *ScopeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_scope
}

func (*ScopeContext) IsScopeContext() {}

func NewScopeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScopeContext {
	var p = new(ScopeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_scope

	return p
}

func (s *ScopeContext) GetParser() antlr.Parser { return s.parser }

func (s *ScopeContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLBRACE, 0)
}

func (s *ScopeContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRBRACE, 0)
}

func (s *ScopeContext) AllStatementOrScope() []IStatementOrScopeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementOrScopeContext); ok {
			len++
		}
	}

	tst := make([]IStatementOrScopeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementOrScopeContext); ok {
			tst[i] = t.(IStatementOrScopeContext)
			i++
		}
	}

	return tst
}

func (s *ScopeContext) StatementOrScope(i int) IStatementOrScopeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementOrScopeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementOrScopeContext)
}

func (s *ScopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScopeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterScope(s)
	}
}

func (s *ScopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitScope(s)
	}
}

func (s *ScopeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitScope(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) Scope() (localctx IScopeContext) {
	localctx = NewScopeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, qasm3ParserRULE_scope)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(191)
		p.Match(qasm3ParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(195)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1512644325007671292) != 0) || ((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&268179457) != 0) {
		{
			p.SetState(192)
			p.StatementOrScope()
		}

		p.SetState(197)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(198)
		p.Match(qasm3ParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPragmaContext is an interface to support dynamic dispatch.
type IPragmaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PRAGMA() antlr.TerminalNode
	RemainingLineContent() antlr.TerminalNode

	// IsPragmaContext differentiates from other interfaces.
	IsPragmaContext()
}

type PragmaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPragmaContext() *PragmaContext {
	var p = new(PragmaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_pragma
	return p
}

func InitEmptyPragmaContext(p *PragmaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_pragma
}

func (*PragmaContext) IsPragmaContext() {}

func NewPragmaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PragmaContext {
	var p = new(PragmaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_pragma

	return p
}

func (s *PragmaContext) GetParser() antlr.Parser { return s.parser }

func (s *PragmaContext) PRAGMA() antlr.TerminalNode {
	return s.GetToken(qasm3ParserPRAGMA, 0)
}

func (s *PragmaContext) RemainingLineContent() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRemainingLineContent, 0)
}

func (s *PragmaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PragmaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PragmaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterPragma(s)
	}
}

func (s *PragmaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitPragma(s)
	}
}

func (s *PragmaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitPragma(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) Pragma() (localctx IPragmaContext) {
	localctx = NewPragmaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, qasm3ParserRULE_pragma)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(200)
		p.Match(qasm3ParserPRAGMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(201)
		p.Match(qasm3ParserRemainingLineContent)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementOrScopeContext is an interface to support dynamic dispatch.
type IStatementOrScopeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Statement() IStatementContext
	Scope() IScopeContext

	// IsStatementOrScopeContext differentiates from other interfaces.
	IsStatementOrScopeContext()
}

type StatementOrScopeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementOrScopeContext() *StatementOrScopeContext {
	var p = new(StatementOrScopeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_statementOrScope
	return p
}

func InitEmptyStatementOrScopeContext(p *StatementOrScopeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_statementOrScope
}

func (*StatementOrScopeContext) IsStatementOrScopeContext() {}

func NewStatementOrScopeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementOrScopeContext {
	var p = new(StatementOrScopeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_statementOrScope

	return p
}

func (s *StatementOrScopeContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementOrScopeContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementOrScopeContext) Scope() IScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScopeContext)
}

func (s *StatementOrScopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementOrScopeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementOrScopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterStatementOrScope(s)
	}
}

func (s *StatementOrScopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitStatementOrScope(s)
	}
}

func (s *StatementOrScopeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitStatementOrScope(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) StatementOrScope() (localctx IStatementOrScopeContext) {
	localctx = NewStatementOrScopeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, qasm3ParserRULE_statementOrScope)
	p.SetState(205)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserINCLUDE, qasm3ParserDEFCALGRAMMAR, qasm3ParserDEF, qasm3ParserCAL, qasm3ParserDEFCAL, qasm3ParserGATE, qasm3ParserEXTERN, qasm3ParserBOX, qasm3ParserLET, qasm3ParserBREAK, qasm3ParserCONTINUE, qasm3ParserIF, qasm3ParserEND, qasm3ParserRETURN, qasm3ParserFOR, qasm3ParserWHILE, qasm3ParserSWITCH, qasm3ParserPRAGMA, qasm3ParserAnnotationKeyword, qasm3ParserINPUT, qasm3ParserOUTPUT, qasm3ParserCONST, qasm3ParserQREG, qasm3ParserQUBIT, qasm3ParserCREG, qasm3ParserBOOL, qasm3ParserBIT, qasm3ParserINT, qasm3ParserUINT, qasm3ParserFLOAT, qasm3ParserANGLE, qasm3ParserCOMPLEX, qasm3ParserARRAY, qasm3ParserDURATION, qasm3ParserSTRETCH, qasm3ParserGPHASE, qasm3ParserINV, qasm3ParserPOW, qasm3ParserCTRL, qasm3ParserNEGCTRL, qasm3ParserDURATIONOF, qasm3ParserDELAY, qasm3ParserRESET, qasm3ParserMEASURE, qasm3ParserBARRIER, qasm3ParserBooleanLiteral, qasm3ParserLPAREN, qasm3ParserMINUS, qasm3ParserTILDE, qasm3ParserEXCLAMATION_POINT, qasm3ParserImaginaryLiteral, qasm3ParserBinaryIntegerLiteral, qasm3ParserOctalIntegerLiteral, qasm3ParserDecimalIntegerLiteral, qasm3ParserHexIntegerLiteral, qasm3ParserIdentifier, qasm3ParserHardwareQubit, qasm3ParserFloatLiteral, qasm3ParserTimingLiteral, qasm3ParserBitstringLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(203)
			p.Statement()
		}

	case qasm3ParserLBRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(204)
			p.Scope()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICalibrationGrammarStatementContext is an interface to support dynamic dispatch.
type ICalibrationGrammarStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFCALGRAMMAR() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode

	// IsCalibrationGrammarStatementContext differentiates from other interfaces.
	IsCalibrationGrammarStatementContext()
}

type CalibrationGrammarStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCalibrationGrammarStatementContext() *CalibrationGrammarStatementContext {
	var p = new(CalibrationGrammarStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_calibrationGrammarStatement
	return p
}

func InitEmptyCalibrationGrammarStatementContext(p *CalibrationGrammarStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_calibrationGrammarStatement
}

func (*CalibrationGrammarStatementContext) IsCalibrationGrammarStatementContext() {}

func NewCalibrationGrammarStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CalibrationGrammarStatementContext {
	var p = new(CalibrationGrammarStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_calibrationGrammarStatement

	return p
}

func (s *CalibrationGrammarStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CalibrationGrammarStatementContext) DEFCALGRAMMAR() antlr.TerminalNode {
	return s.GetToken(qasm3ParserDEFCALGRAMMAR, 0)
}

func (s *CalibrationGrammarStatementContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(qasm3ParserStringLiteral, 0)
}

func (s *CalibrationGrammarStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *CalibrationGrammarStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CalibrationGrammarStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CalibrationGrammarStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterCalibrationGrammarStatement(s)
	}
}

func (s *CalibrationGrammarStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitCalibrationGrammarStatement(s)
	}
}

func (s *CalibrationGrammarStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitCalibrationGrammarStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) CalibrationGrammarStatement() (localctx ICalibrationGrammarStatementContext) {
	localctx = NewCalibrationGrammarStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, qasm3ParserRULE_calibrationGrammarStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(207)
		p.Match(qasm3ParserDEFCALGRAMMAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(208)
		p.Match(qasm3ParserStringLiteral)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(209)
		p.Match(qasm3ParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIncludeStatementContext is an interface to support dynamic dispatch.
type IIncludeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INCLUDE() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode

	// IsIncludeStatementContext differentiates from other interfaces.
	IsIncludeStatementContext()
}

type IncludeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIncludeStatementContext() *IncludeStatementContext {
	var p = new(IncludeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_includeStatement
	return p
}

func InitEmptyIncludeStatementContext(p *IncludeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_includeStatement
}

func (*IncludeStatementContext) IsIncludeStatementContext() {}

func NewIncludeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IncludeStatementContext {
	var p = new(IncludeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_includeStatement

	return p
}

func (s *IncludeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IncludeStatementContext) INCLUDE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserINCLUDE, 0)
}

func (s *IncludeStatementContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(qasm3ParserStringLiteral, 0)
}

func (s *IncludeStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *IncludeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IncludeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IncludeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterIncludeStatement(s)
	}
}

func (s *IncludeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitIncludeStatement(s)
	}
}

func (s *IncludeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitIncludeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) IncludeStatement() (localctx IIncludeStatementContext) {
	localctx = NewIncludeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, qasm3ParserRULE_includeStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(211)
		p.Match(qasm3ParserINCLUDE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(212)
		p.Match(qasm3ParserStringLiteral)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(213)
		p.Match(qasm3ParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBreakStatementContext is an interface to support dynamic dispatch.
type IBreakStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BREAK() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode

	// IsBreakStatementContext differentiates from other interfaces.
	IsBreakStatementContext()
}

type BreakStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStatementContext() *BreakStatementContext {
	var p = new(BreakStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_breakStatement
	return p
}

func InitEmptyBreakStatementContext(p *BreakStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_breakStatement
}

func (*BreakStatementContext) IsBreakStatementContext() {}

func NewBreakStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStatementContext {
	var p = new(BreakStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_breakStatement

	return p
}

func (s *BreakStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStatementContext) BREAK() antlr.TerminalNode {
	return s.GetToken(qasm3ParserBREAK, 0)
}

func (s *BreakStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *BreakStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterBreakStatement(s)
	}
}

func (s *BreakStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitBreakStatement(s)
	}
}

func (s *BreakStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitBreakStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) BreakStatement() (localctx IBreakStatementContext) {
	localctx = NewBreakStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, qasm3ParserRULE_breakStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(215)
		p.Match(qasm3ParserBREAK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(216)
		p.Match(qasm3ParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONTINUE() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_continueStatement
	return p
}

func InitEmptyContinueStatementContext(p *ContinueStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_continueStatement
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserCONTINUE, 0)
}

func (s *ContinueStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterContinueStatement(s)
	}
}

func (s *ContinueStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitContinueStatement(s)
	}
}

func (s *ContinueStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitContinueStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ContinueStatement() (localctx IContinueStatementContext) {
	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, qasm3ParserRULE_continueStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(218)
		p.Match(qasm3ParserCONTINUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(219)
		p.Match(qasm3ParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEndStatementContext is an interface to support dynamic dispatch.
type IEndStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	END() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode

	// IsEndStatementContext differentiates from other interfaces.
	IsEndStatementContext()
}

type EndStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEndStatementContext() *EndStatementContext {
	var p = new(EndStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_endStatement
	return p
}

func InitEmptyEndStatementContext(p *EndStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_endStatement
}

func (*EndStatementContext) IsEndStatementContext() {}

func NewEndStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EndStatementContext {
	var p = new(EndStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_endStatement

	return p
}

func (s *EndStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EndStatementContext) END() antlr.TerminalNode {
	return s.GetToken(qasm3ParserEND, 0)
}

func (s *EndStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *EndStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EndStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EndStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterEndStatement(s)
	}
}

func (s *EndStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitEndStatement(s)
	}
}

func (s *EndStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitEndStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) EndStatement() (localctx IEndStatementContext) {
	localctx = NewEndStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, qasm3ParserRULE_endStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(221)
		p.Match(qasm3ParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(222)
		p.Match(qasm3ParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBody returns the body rule contexts.
	GetBody() IStatementOrScopeContext

	// SetBody sets the body rule contexts.
	SetBody(IStatementOrScopeContext)

	// Getter signatures
	FOR() antlr.TerminalNode
	ScalarType() IScalarTypeContext
	Identifier() antlr.TerminalNode
	IN() antlr.TerminalNode
	StatementOrScope() IStatementOrScopeContext
	SetExpression() ISetExpressionContext
	LBRACKET() antlr.TerminalNode
	RangeExpression() IRangeExpressionContext
	RBRACKET() antlr.TerminalNode
	Expression() IExpressionContext

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	body   IStatementOrScopeContext
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_forStatement
	return p
}

func InitEmptyForStatementContext(p *ForStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_forStatement
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) GetBody() IStatementOrScopeContext { return s.body }

func (s *ForStatementContext) SetBody(v IStatementOrScopeContext) { s.body = v }

func (s *ForStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(qasm3ParserFOR, 0)
}

func (s *ForStatementContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *ForStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *ForStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIN, 0)
}

func (s *ForStatementContext) StatementOrScope() IStatementOrScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementOrScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementOrScopeContext)
}

func (s *ForStatementContext) SetExpression() ISetExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetExpressionContext)
}

func (s *ForStatementContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLBRACKET, 0)
}

func (s *ForStatementContext) RangeExpression() IRangeExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeExpressionContext)
}

func (s *ForStatementContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRBRACKET, 0)
}

func (s *ForStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitForStatement(s)
	}
}

func (s *ForStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitForStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ForStatement() (localctx IForStatementContext) {
	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, qasm3ParserRULE_forStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(224)
		p.Match(qasm3ParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(225)
		p.ScalarType()
	}
	{
		p.SetState(226)
		p.Match(qasm3ParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(227)
		p.Match(qasm3ParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(234)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserLBRACE:
		{
			p.SetState(228)
			p.SetExpression()
		}

	case qasm3ParserLBRACKET:
		{
			p.SetState(229)
			p.Match(qasm3ParserLBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(230)
			p.RangeExpression()
		}
		{
			p.SetState(231)
			p.Match(qasm3ParserRBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case qasm3ParserBOOL, qasm3ParserBIT, qasm3ParserINT, qasm3ParserUINT, qasm3ParserFLOAT, qasm3ParserANGLE, qasm3ParserCOMPLEX, qasm3ParserARRAY, qasm3ParserDURATION, qasm3ParserSTRETCH, qasm3ParserDURATIONOF, qasm3ParserBooleanLiteral, qasm3ParserLPAREN, qasm3ParserMINUS, qasm3ParserTILDE, qasm3ParserEXCLAMATION_POINT, qasm3ParserImaginaryLiteral, qasm3ParserBinaryIntegerLiteral, qasm3ParserOctalIntegerLiteral, qasm3ParserDecimalIntegerLiteral, qasm3ParserHexIntegerLiteral, qasm3ParserIdentifier, qasm3ParserHardwareQubit, qasm3ParserFloatLiteral, qasm3ParserTimingLiteral, qasm3ParserBitstringLiteral:
		{
			p.SetState(233)
			p.expression(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(236)

		var _x = p.StatementOrScope()

		localctx.(*ForStatementContext).body = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIf_body returns the if_body rule contexts.
	GetIf_body() IStatementOrScopeContext

	// GetElse_body returns the else_body rule contexts.
	GetElse_body() IStatementOrScopeContext

	// SetIf_body sets the if_body rule contexts.
	SetIf_body(IStatementOrScopeContext)

	// SetElse_body sets the else_body rule contexts.
	SetElse_body(IStatementOrScopeContext)

	// Getter signatures
	IF() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	AllStatementOrScope() []IStatementOrScopeContext
	StatementOrScope(i int) IStatementOrScopeContext
	ELSE() antlr.TerminalNode

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	if_body   IStatementOrScopeContext
	else_body IStatementOrScopeContext
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_ifStatement
	return p
}

func InitEmptyIfStatementContext(p *IfStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_ifStatement
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) GetIf_body() IStatementOrScopeContext { return s.if_body }

func (s *IfStatementContext) GetElse_body() IStatementOrScopeContext { return s.else_body }

func (s *IfStatementContext) SetIf_body(v IStatementOrScopeContext) { s.if_body = v }

func (s *IfStatementContext) SetElse_body(v IStatementOrScopeContext) { s.else_body = v }

func (s *IfStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIF, 0)
}

func (s *IfStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLPAREN, 0)
}

func (s *IfStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRPAREN, 0)
}

func (s *IfStatementContext) AllStatementOrScope() []IStatementOrScopeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementOrScopeContext); ok {
			len++
		}
	}

	tst := make([]IStatementOrScopeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementOrScopeContext); ok {
			tst[i] = t.(IStatementOrScopeContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) StatementOrScope(i int) IStatementOrScopeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementOrScopeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementOrScopeContext)
}

func (s *IfStatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserELSE, 0)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (s *IfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitIfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) IfStatement() (localctx IIfStatementContext) {
	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, qasm3ParserRULE_ifStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(238)
		p.Match(qasm3ParserIF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(239)
		p.Match(qasm3ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(240)
		p.expression(0)
	}
	{
		p.SetState(241)
		p.Match(qasm3ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(242)

		var _x = p.StatementOrScope()

		localctx.(*IfStatementContext).if_body = _x
	}
	p.SetState(245)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(243)
			p.Match(qasm3ParserELSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(244)

			var _x = p.StatementOrScope()

			localctx.(*IfStatementContext).else_body = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURN() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode
	Expression() IExpressionContext
	MeasureExpression() IMeasureExpressionContext

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_returnStatement
	return p
}

func InitEmptyReturnStatementContext(p *ReturnStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_returnStatement
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRETURN, 0)
}

func (s *ReturnStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *ReturnStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnStatementContext) MeasureExpression() IMeasureExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMeasureExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMeasureExpressionContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (s *ReturnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitReturnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ReturnStatement() (localctx IReturnStatementContext) {
	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, qasm3ParserRULE_returnStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(247)
		p.Match(qasm3ParserRETURN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(250)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case qasm3ParserBOOL, qasm3ParserBIT, qasm3ParserINT, qasm3ParserUINT, qasm3ParserFLOAT, qasm3ParserANGLE, qasm3ParserCOMPLEX, qasm3ParserARRAY, qasm3ParserDURATION, qasm3ParserSTRETCH, qasm3ParserDURATIONOF, qasm3ParserBooleanLiteral, qasm3ParserLPAREN, qasm3ParserMINUS, qasm3ParserTILDE, qasm3ParserEXCLAMATION_POINT, qasm3ParserImaginaryLiteral, qasm3ParserBinaryIntegerLiteral, qasm3ParserOctalIntegerLiteral, qasm3ParserDecimalIntegerLiteral, qasm3ParserHexIntegerLiteral, qasm3ParserIdentifier, qasm3ParserHardwareQubit, qasm3ParserFloatLiteral, qasm3ParserTimingLiteral, qasm3ParserBitstringLiteral:
		{
			p.SetState(248)
			p.expression(0)
		}

	case qasm3ParserMEASURE:
		{
			p.SetState(249)
			p.MeasureExpression()
		}

	case qasm3ParserSEMICOLON:

	default:
	}
	{
		p.SetState(252)
		p.Match(qasm3ParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBody returns the body rule contexts.
	GetBody() IStatementOrScopeContext

	// SetBody sets the body rule contexts.
	SetBody(IStatementOrScopeContext)

	// Getter signatures
	WHILE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	StatementOrScope() IStatementOrScopeContext

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	body   IStatementOrScopeContext
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_whileStatement
	return p
}

func InitEmptyWhileStatementContext(p *WhileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_whileStatement
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) GetBody() IStatementOrScopeContext { return s.body }

func (s *WhileStatementContext) SetBody(v IStatementOrScopeContext) { s.body = v }

func (s *WhileStatementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserWHILE, 0)
}

func (s *WhileStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLPAREN, 0)
}

func (s *WhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRPAREN, 0)
}

func (s *WhileStatementContext) StatementOrScope() IStatementOrScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementOrScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementOrScopeContext)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (s *WhileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitWhileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) WhileStatement() (localctx IWhileStatementContext) {
	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, qasm3ParserRULE_whileStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(254)
		p.Match(qasm3ParserWHILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(255)
		p.Match(qasm3ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(256)
		p.expression(0)
	}
	{
		p.SetState(257)
		p.Match(qasm3ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(258)

		var _x = p.StatementOrScope()

		localctx.(*WhileStatementContext).body = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitchStatementContext is an interface to support dynamic dispatch.
type ISwitchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SWITCH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllSwitchCaseItem() []ISwitchCaseItemContext
	SwitchCaseItem(i int) ISwitchCaseItemContext

	// IsSwitchStatementContext differentiates from other interfaces.
	IsSwitchStatementContext()
}

type SwitchStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchStatementContext() *SwitchStatementContext {
	var p = new(SwitchStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_switchStatement
	return p
}

func InitEmptySwitchStatementContext(p *SwitchStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_switchStatement
}

func (*SwitchStatementContext) IsSwitchStatementContext() {}

func NewSwitchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchStatementContext {
	var p = new(SwitchStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_switchStatement

	return p
}

func (s *SwitchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchStatementContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSWITCH, 0)
}

func (s *SwitchStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLPAREN, 0)
}

func (s *SwitchStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SwitchStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRPAREN, 0)
}

func (s *SwitchStatementContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLBRACE, 0)
}

func (s *SwitchStatementContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRBRACE, 0)
}

func (s *SwitchStatementContext) AllSwitchCaseItem() []ISwitchCaseItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISwitchCaseItemContext); ok {
			len++
		}
	}

	tst := make([]ISwitchCaseItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISwitchCaseItemContext); ok {
			tst[i] = t.(ISwitchCaseItemContext)
			i++
		}
	}

	return tst
}

func (s *SwitchStatementContext) SwitchCaseItem(i int) ISwitchCaseItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwitchCaseItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwitchCaseItemContext)
}

func (s *SwitchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterSwitchStatement(s)
	}
}

func (s *SwitchStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitSwitchStatement(s)
	}
}

func (s *SwitchStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitSwitchStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) SwitchStatement() (localctx ISwitchStatementContext) {
	localctx = NewSwitchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, qasm3ParserRULE_switchStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(260)
		p.Match(qasm3ParserSWITCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(261)
		p.Match(qasm3ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(262)
		p.expression(0)
	}
	{
		p.SetState(263)
		p.Match(qasm3ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(264)
		p.Match(qasm3ParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(268)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == qasm3ParserCASE || _la == qasm3ParserDEFAULT {
		{
			p.SetState(265)
			p.SwitchCaseItem()
		}

		p.SetState(270)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(271)
		p.Match(qasm3ParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwitchCaseItemContext is an interface to support dynamic dispatch.
type ISwitchCaseItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	ExpressionList() IExpressionListContext
	Scope() IScopeContext
	DEFAULT() antlr.TerminalNode

	// IsSwitchCaseItemContext differentiates from other interfaces.
	IsSwitchCaseItemContext()
}

type SwitchCaseItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitchCaseItemContext() *SwitchCaseItemContext {
	var p = new(SwitchCaseItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_switchCaseItem
	return p
}

func InitEmptySwitchCaseItemContext(p *SwitchCaseItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_switchCaseItem
}

func (*SwitchCaseItemContext) IsSwitchCaseItemContext() {}

func NewSwitchCaseItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwitchCaseItemContext {
	var p = new(SwitchCaseItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_switchCaseItem

	return p
}

func (s *SwitchCaseItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SwitchCaseItemContext) CASE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserCASE, 0)
}

func (s *SwitchCaseItemContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *SwitchCaseItemContext) Scope() IScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScopeContext)
}

func (s *SwitchCaseItemContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(qasm3ParserDEFAULT, 0)
}

func (s *SwitchCaseItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwitchCaseItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwitchCaseItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterSwitchCaseItem(s)
	}
}

func (s *SwitchCaseItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitSwitchCaseItem(s)
	}
}

func (s *SwitchCaseItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitSwitchCaseItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) SwitchCaseItem() (localctx ISwitchCaseItemContext) {
	localctx = NewSwitchCaseItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, qasm3ParserRULE_switchCaseItem)
	p.SetState(279)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserCASE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(273)
			p.Match(qasm3ParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(274)
			p.ExpressionList()
		}
		{
			p.SetState(275)
			p.Scope()
		}

	case qasm3ParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(277)
			p.Match(qasm3ParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(278)
			p.Scope()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBarrierStatementContext is an interface to support dynamic dispatch.
type IBarrierStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BARRIER() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode
	GateOperandList() IGateOperandListContext

	// IsBarrierStatementContext differentiates from other interfaces.
	IsBarrierStatementContext()
}

type BarrierStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBarrierStatementContext() *BarrierStatementContext {
	var p = new(BarrierStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_barrierStatement
	return p
}

func InitEmptyBarrierStatementContext(p *BarrierStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_barrierStatement
}

func (*BarrierStatementContext) IsBarrierStatementContext() {}

func NewBarrierStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BarrierStatementContext {
	var p = new(BarrierStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_barrierStatement

	return p
}

func (s *BarrierStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BarrierStatementContext) BARRIER() antlr.TerminalNode {
	return s.GetToken(qasm3ParserBARRIER, 0)
}

func (s *BarrierStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *BarrierStatementContext) GateOperandList() IGateOperandListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGateOperandListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGateOperandListContext)
}

func (s *BarrierStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BarrierStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BarrierStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterBarrierStatement(s)
	}
}

func (s *BarrierStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitBarrierStatement(s)
	}
}

func (s *BarrierStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitBarrierStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) BarrierStatement() (localctx IBarrierStatementContext) {
	localctx = NewBarrierStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, qasm3ParserRULE_barrierStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(281)
		p.Match(qasm3ParserBARRIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(283)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserIdentifier || _la == qasm3ParserHardwareQubit {
		{
			p.SetState(282)
			p.GateOperandList()
		}

	}
	{
		p.SetState(285)
		p.Match(qasm3ParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBoxStatementContext is an interface to support dynamic dispatch.
type IBoxStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BOX() antlr.TerminalNode
	Scope() IScopeContext
	Designator() IDesignatorContext

	// IsBoxStatementContext differentiates from other interfaces.
	IsBoxStatementContext()
}

type BoxStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBoxStatementContext() *BoxStatementContext {
	var p = new(BoxStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_boxStatement
	return p
}

func InitEmptyBoxStatementContext(p *BoxStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_boxStatement
}

func (*BoxStatementContext) IsBoxStatementContext() {}

func NewBoxStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BoxStatementContext {
	var p = new(BoxStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_boxStatement

	return p
}

func (s *BoxStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BoxStatementContext) BOX() antlr.TerminalNode {
	return s.GetToken(qasm3ParserBOX, 0)
}

func (s *BoxStatementContext) Scope() IScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScopeContext)
}

func (s *BoxStatementContext) Designator() IDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDesignatorContext)
}

func (s *BoxStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoxStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BoxStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterBoxStatement(s)
	}
}

func (s *BoxStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitBoxStatement(s)
	}
}

func (s *BoxStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitBoxStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) BoxStatement() (localctx IBoxStatementContext) {
	localctx = NewBoxStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, qasm3ParserRULE_boxStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(287)
		p.Match(qasm3ParserBOX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(289)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserLBRACKET {
		{
			p.SetState(288)
			p.Designator()
		}

	}
	{
		p.SetState(291)
		p.Scope()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDelayStatementContext is an interface to support dynamic dispatch.
type IDelayStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELAY() antlr.TerminalNode
	Designator() IDesignatorContext
	SEMICOLON() antlr.TerminalNode
	GateOperandList() IGateOperandListContext

	// IsDelayStatementContext differentiates from other interfaces.
	IsDelayStatementContext()
}

type DelayStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelayStatementContext() *DelayStatementContext {
	var p = new(DelayStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_delayStatement
	return p
}

func InitEmptyDelayStatementContext(p *DelayStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_delayStatement
}

func (*DelayStatementContext) IsDelayStatementContext() {}

func NewDelayStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DelayStatementContext {
	var p = new(DelayStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_delayStatement

	return p
}

func (s *DelayStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DelayStatementContext) DELAY() antlr.TerminalNode {
	return s.GetToken(qasm3ParserDELAY, 0)
}

func (s *DelayStatementContext) Designator() IDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDesignatorContext)
}

func (s *DelayStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *DelayStatementContext) GateOperandList() IGateOperandListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGateOperandListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGateOperandListContext)
}

func (s *DelayStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DelayStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DelayStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterDelayStatement(s)
	}
}

func (s *DelayStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitDelayStatement(s)
	}
}

func (s *DelayStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitDelayStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) DelayStatement() (localctx IDelayStatementContext) {
	localctx = NewDelayStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, qasm3ParserRULE_delayStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(293)
		p.Match(qasm3ParserDELAY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(294)
		p.Designator()
	}
	p.SetState(296)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserIdentifier || _la == qasm3ParserHardwareQubit {
		{
			p.SetState(295)
			p.GateOperandList()
		}

	}
	{
		p.SetState(298)
		p.Match(qasm3ParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGateCallStatementContext is an interface to support dynamic dispatch.
type IGateCallStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	GateOperandList() IGateOperandListContext
	SEMICOLON() antlr.TerminalNode
	AllGateModifier() []IGateModifierContext
	GateModifier(i int) IGateModifierContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Designator() IDesignatorContext
	ExpressionList() IExpressionListContext
	GPHASE() antlr.TerminalNode

	// IsGateCallStatementContext differentiates from other interfaces.
	IsGateCallStatementContext()
}

type GateCallStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGateCallStatementContext() *GateCallStatementContext {
	var p = new(GateCallStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_gateCallStatement
	return p
}

func InitEmptyGateCallStatementContext(p *GateCallStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_gateCallStatement
}

func (*GateCallStatementContext) IsGateCallStatementContext() {}

func NewGateCallStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GateCallStatementContext {
	var p = new(GateCallStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_gateCallStatement

	return p
}

func (s *GateCallStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GateCallStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *GateCallStatementContext) GateOperandList() IGateOperandListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGateOperandListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGateOperandListContext)
}

func (s *GateCallStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *GateCallStatementContext) AllGateModifier() []IGateModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGateModifierContext); ok {
			len++
		}
	}

	tst := make([]IGateModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGateModifierContext); ok {
			tst[i] = t.(IGateModifierContext)
			i++
		}
	}

	return tst
}

func (s *GateCallStatementContext) GateModifier(i int) IGateModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGateModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGateModifierContext)
}

func (s *GateCallStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLPAREN, 0)
}

func (s *GateCallStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRPAREN, 0)
}

func (s *GateCallStatementContext) Designator() IDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDesignatorContext)
}

func (s *GateCallStatementContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *GateCallStatementContext) GPHASE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserGPHASE, 0)
}

func (s *GateCallStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GateCallStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GateCallStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterGateCallStatement(s)
	}
}

func (s *GateCallStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitGateCallStatement(s)
	}
}

func (s *GateCallStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitGateCallStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) GateCallStatement() (localctx IGateCallStatementContext) {
	localctx = NewGateCallStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, qasm3ParserRULE_gateCallStatement)
	var _la int

	p.SetState(341)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(303)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&527765581332480) != 0 {
			{
				p.SetState(300)
				p.GateModifier()
			}

			p.SetState(305)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(306)
			p.Match(qasm3ParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(312)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserLPAREN {
			{
				p.SetState(307)
				p.Match(qasm3ParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(309)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1190091586105507840) != 0) || ((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&268179457) != 0) {
				{
					p.SetState(308)
					p.ExpressionList()
				}

			}
			{
				p.SetState(311)
				p.Match(qasm3ParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(315)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserLBRACKET {
			{
				p.SetState(314)
				p.Designator()
			}

		}
		{
			p.SetState(317)
			p.GateOperandList()
		}
		{
			p.SetState(318)
			p.Match(qasm3ParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(323)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&527765581332480) != 0 {
			{
				p.SetState(320)
				p.GateModifier()
			}

			p.SetState(325)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(326)
			p.Match(qasm3ParserGPHASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(332)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserLPAREN {
			{
				p.SetState(327)
				p.Match(qasm3ParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(329)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1190091586105507840) != 0) || ((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&268179457) != 0) {
				{
					p.SetState(328)
					p.ExpressionList()
				}

			}
			{
				p.SetState(331)
				p.Match(qasm3ParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(335)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserLBRACKET {
			{
				p.SetState(334)
				p.Designator()
			}

		}
		p.SetState(338)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserIdentifier || _la == qasm3ParserHardwareQubit {
			{
				p.SetState(337)
				p.GateOperandList()
			}

		}
		{
			p.SetState(340)
			p.Match(qasm3ParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMeasureArrowAssignmentStatementContext is an interface to support dynamic dispatch.
type IMeasureArrowAssignmentStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MeasureExpression() IMeasureExpressionContext
	SEMICOLON() antlr.TerminalNode
	ARROW() antlr.TerminalNode
	IndexedIdentifier() IIndexedIdentifierContext

	// IsMeasureArrowAssignmentStatementContext differentiates from other interfaces.
	IsMeasureArrowAssignmentStatementContext()
}

type MeasureArrowAssignmentStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMeasureArrowAssignmentStatementContext() *MeasureArrowAssignmentStatementContext {
	var p = new(MeasureArrowAssignmentStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_measureArrowAssignmentStatement
	return p
}

func InitEmptyMeasureArrowAssignmentStatementContext(p *MeasureArrowAssignmentStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_measureArrowAssignmentStatement
}

func (*MeasureArrowAssignmentStatementContext) IsMeasureArrowAssignmentStatementContext() {}

func NewMeasureArrowAssignmentStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MeasureArrowAssignmentStatementContext {
	var p = new(MeasureArrowAssignmentStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_measureArrowAssignmentStatement

	return p
}

func (s *MeasureArrowAssignmentStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MeasureArrowAssignmentStatementContext) MeasureExpression() IMeasureExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMeasureExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMeasureExpressionContext)
}

func (s *MeasureArrowAssignmentStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *MeasureArrowAssignmentStatementContext) ARROW() antlr.TerminalNode {
	return s.GetToken(qasm3ParserARROW, 0)
}

func (s *MeasureArrowAssignmentStatementContext) IndexedIdentifier() IIndexedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexedIdentifierContext)
}

func (s *MeasureArrowAssignmentStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MeasureArrowAssignmentStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MeasureArrowAssignmentStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterMeasureArrowAssignmentStatement(s)
	}
}

func (s *MeasureArrowAssignmentStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitMeasureArrowAssignmentStatement(s)
	}
}

func (s *MeasureArrowAssignmentStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitMeasureArrowAssignmentStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) MeasureArrowAssignmentStatement() (localctx IMeasureArrowAssignmentStatementContext) {
	localctx = NewMeasureArrowAssignmentStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, qasm3ParserRULE_measureArrowAssignmentStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(343)
		p.MeasureExpression()
	}
	p.SetState(346)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserARROW {
		{
			p.SetState(344)
			p.Match(qasm3ParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(345)
			p.IndexedIdentifier()
		}

	}
	{
		p.SetState(348)
		p.Match(qasm3ParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResetStatementContext is an interface to support dynamic dispatch.
type IResetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESET() antlr.TerminalNode
	GateOperand() IGateOperandContext
	SEMICOLON() antlr.TerminalNode

	// IsResetStatementContext differentiates from other interfaces.
	IsResetStatementContext()
}

type ResetStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResetStatementContext() *ResetStatementContext {
	var p = new(ResetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_resetStatement
	return p
}

func InitEmptyResetStatementContext(p *ResetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_resetStatement
}

func (*ResetStatementContext) IsResetStatementContext() {}

func NewResetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResetStatementContext {
	var p = new(ResetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_resetStatement

	return p
}

func (s *ResetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ResetStatementContext) RESET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRESET, 0)
}

func (s *ResetStatementContext) GateOperand() IGateOperandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGateOperandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGateOperandContext)
}

func (s *ResetStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *ResetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterResetStatement(s)
	}
}

func (s *ResetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitResetStatement(s)
	}
}

func (s *ResetStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitResetStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ResetStatement() (localctx IResetStatementContext) {
	localctx = NewResetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, qasm3ParserRULE_resetStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(350)
		p.Match(qasm3ParserRESET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(351)
		p.GateOperand()
	}
	{
		p.SetState(352)
		p.Match(qasm3ParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAliasDeclarationStatementContext is an interface to support dynamic dispatch.
type IAliasDeclarationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LET() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	EQUALS() antlr.TerminalNode
	AliasExpression() IAliasExpressionContext
	SEMICOLON() antlr.TerminalNode

	// IsAliasDeclarationStatementContext differentiates from other interfaces.
	IsAliasDeclarationStatementContext()
}

type AliasDeclarationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasDeclarationStatementContext() *AliasDeclarationStatementContext {
	var p = new(AliasDeclarationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_aliasDeclarationStatement
	return p
}

func InitEmptyAliasDeclarationStatementContext(p *AliasDeclarationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_aliasDeclarationStatement
}

func (*AliasDeclarationStatementContext) IsAliasDeclarationStatementContext() {}

func NewAliasDeclarationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasDeclarationStatementContext {
	var p = new(AliasDeclarationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_aliasDeclarationStatement

	return p
}

func (s *AliasDeclarationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasDeclarationStatementContext) LET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLET, 0)
}

func (s *AliasDeclarationStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *AliasDeclarationStatementContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(qasm3ParserEQUALS, 0)
}

func (s *AliasDeclarationStatementContext) AliasExpression() IAliasExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasExpressionContext)
}

func (s *AliasDeclarationStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *AliasDeclarationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasDeclarationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasDeclarationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterAliasDeclarationStatement(s)
	}
}

func (s *AliasDeclarationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitAliasDeclarationStatement(s)
	}
}

func (s *AliasDeclarationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitAliasDeclarationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) AliasDeclarationStatement() (localctx IAliasDeclarationStatementContext) {
	localctx = NewAliasDeclarationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, qasm3ParserRULE_aliasDeclarationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(354)
		p.Match(qasm3ParserLET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(355)
		p.Match(qasm3ParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(356)
		p.Match(qasm3ParserEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(357)
		p.AliasExpression()
	}
	{
		p.SetState(358)
		p.Match(qasm3ParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassicalDeclarationStatementContext is an interface to support dynamic dispatch.
type IClassicalDeclarationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode
	ScalarType() IScalarTypeContext
	ArrayType() IArrayTypeContext
	EQUALS() antlr.TerminalNode
	DeclarationExpression() IDeclarationExpressionContext

	// IsClassicalDeclarationStatementContext differentiates from other interfaces.
	IsClassicalDeclarationStatementContext()
}

type ClassicalDeclarationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassicalDeclarationStatementContext() *ClassicalDeclarationStatementContext {
	var p = new(ClassicalDeclarationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_classicalDeclarationStatement
	return p
}

func InitEmptyClassicalDeclarationStatementContext(p *ClassicalDeclarationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_classicalDeclarationStatement
}

func (*ClassicalDeclarationStatementContext) IsClassicalDeclarationStatementContext() {}

func NewClassicalDeclarationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassicalDeclarationStatementContext {
	var p = new(ClassicalDeclarationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_classicalDeclarationStatement

	return p
}

func (s *ClassicalDeclarationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassicalDeclarationStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *ClassicalDeclarationStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *ClassicalDeclarationStatementContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *ClassicalDeclarationStatementContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *ClassicalDeclarationStatementContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(qasm3ParserEQUALS, 0)
}

func (s *ClassicalDeclarationStatementContext) DeclarationExpression() IDeclarationExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationExpressionContext)
}

func (s *ClassicalDeclarationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassicalDeclarationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassicalDeclarationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterClassicalDeclarationStatement(s)
	}
}

func (s *ClassicalDeclarationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitClassicalDeclarationStatement(s)
	}
}

func (s *ClassicalDeclarationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitClassicalDeclarationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ClassicalDeclarationStatement() (localctx IClassicalDeclarationStatementContext) {
	localctx = NewClassicalDeclarationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, qasm3ParserRULE_classicalDeclarationStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(362)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserBOOL, qasm3ParserBIT, qasm3ParserINT, qasm3ParserUINT, qasm3ParserFLOAT, qasm3ParserANGLE, qasm3ParserCOMPLEX, qasm3ParserDURATION, qasm3ParserSTRETCH:
		{
			p.SetState(360)
			p.ScalarType()
		}

	case qasm3ParserARRAY:
		{
			p.SetState(361)
			p.ArrayType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(364)
		p.Match(qasm3ParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(367)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserEQUALS {
		{
			p.SetState(365)
			p.Match(qasm3ParserEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(366)
			p.DeclarationExpression()
		}

	}
	{
		p.SetState(369)
		p.Match(qasm3ParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstDeclarationStatementContext is an interface to support dynamic dispatch.
type IConstDeclarationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONST() antlr.TerminalNode
	ScalarType() IScalarTypeContext
	Identifier() antlr.TerminalNode
	EQUALS() antlr.TerminalNode
	DeclarationExpression() IDeclarationExpressionContext
	SEMICOLON() antlr.TerminalNode

	// IsConstDeclarationStatementContext differentiates from other interfaces.
	IsConstDeclarationStatementContext()
}

type ConstDeclarationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstDeclarationStatementContext() *ConstDeclarationStatementContext {
	var p = new(ConstDeclarationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_constDeclarationStatement
	return p
}

func InitEmptyConstDeclarationStatementContext(p *ConstDeclarationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_constDeclarationStatement
}

func (*ConstDeclarationStatementContext) IsConstDeclarationStatementContext() {}

func NewConstDeclarationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstDeclarationStatementContext {
	var p = new(ConstDeclarationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_constDeclarationStatement

	return p
}

func (s *ConstDeclarationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstDeclarationStatementContext) CONST() antlr.TerminalNode {
	return s.GetToken(qasm3ParserCONST, 0)
}

func (s *ConstDeclarationStatementContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *ConstDeclarationStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *ConstDeclarationStatementContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(qasm3ParserEQUALS, 0)
}

func (s *ConstDeclarationStatementContext) DeclarationExpression() IDeclarationExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationExpressionContext)
}

func (s *ConstDeclarationStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *ConstDeclarationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstDeclarationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstDeclarationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterConstDeclarationStatement(s)
	}
}

func (s *ConstDeclarationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitConstDeclarationStatement(s)
	}
}

func (s *ConstDeclarationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitConstDeclarationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ConstDeclarationStatement() (localctx IConstDeclarationStatementContext) {
	localctx = NewConstDeclarationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, qasm3ParserRULE_constDeclarationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(371)
		p.Match(qasm3ParserCONST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(372)
		p.ScalarType()
	}
	{
		p.SetState(373)
		p.Match(qasm3ParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(374)
		p.Match(qasm3ParserEQUALS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(375)
		p.DeclarationExpression()
	}
	{
		p.SetState(376)
		p.Match(qasm3ParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIoDeclarationStatementContext is an interface to support dynamic dispatch.
type IIoDeclarationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode
	INPUT() antlr.TerminalNode
	OUTPUT() antlr.TerminalNode
	ScalarType() IScalarTypeContext
	ArrayType() IArrayTypeContext

	// IsIoDeclarationStatementContext differentiates from other interfaces.
	IsIoDeclarationStatementContext()
}

type IoDeclarationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIoDeclarationStatementContext() *IoDeclarationStatementContext {
	var p = new(IoDeclarationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_ioDeclarationStatement
	return p
}

func InitEmptyIoDeclarationStatementContext(p *IoDeclarationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_ioDeclarationStatement
}

func (*IoDeclarationStatementContext) IsIoDeclarationStatementContext() {}

func NewIoDeclarationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IoDeclarationStatementContext {
	var p = new(IoDeclarationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_ioDeclarationStatement

	return p
}

func (s *IoDeclarationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IoDeclarationStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *IoDeclarationStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *IoDeclarationStatementContext) INPUT() antlr.TerminalNode {
	return s.GetToken(qasm3ParserINPUT, 0)
}

func (s *IoDeclarationStatementContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(qasm3ParserOUTPUT, 0)
}

func (s *IoDeclarationStatementContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *IoDeclarationStatementContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *IoDeclarationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IoDeclarationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IoDeclarationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterIoDeclarationStatement(s)
	}
}

func (s *IoDeclarationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitIoDeclarationStatement(s)
	}
}

func (s *IoDeclarationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitIoDeclarationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) IoDeclarationStatement() (localctx IIoDeclarationStatementContext) {
	localctx = NewIoDeclarationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, qasm3ParserRULE_ioDeclarationStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(378)
		_la = p.GetTokenStream().LA(1)

		if !(_la == qasm3ParserINPUT || _la == qasm3ParserOUTPUT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(381)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserBOOL, qasm3ParserBIT, qasm3ParserINT, qasm3ParserUINT, qasm3ParserFLOAT, qasm3ParserANGLE, qasm3ParserCOMPLEX, qasm3ParserDURATION, qasm3ParserSTRETCH:
		{
			p.SetState(379)
			p.ScalarType()
		}

	case qasm3ParserARRAY:
		{
			p.SetState(380)
			p.ArrayType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(383)
		p.Match(qasm3ParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(384)
		p.Match(qasm3ParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOldStyleDeclarationStatementContext is an interface to support dynamic dispatch.
type IOldStyleDeclarationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode
	CREG() antlr.TerminalNode
	QREG() antlr.TerminalNode
	Designator() IDesignatorContext

	// IsOldStyleDeclarationStatementContext differentiates from other interfaces.
	IsOldStyleDeclarationStatementContext()
}

type OldStyleDeclarationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOldStyleDeclarationStatementContext() *OldStyleDeclarationStatementContext {
	var p = new(OldStyleDeclarationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_oldStyleDeclarationStatement
	return p
}

func InitEmptyOldStyleDeclarationStatementContext(p *OldStyleDeclarationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_oldStyleDeclarationStatement
}

func (*OldStyleDeclarationStatementContext) IsOldStyleDeclarationStatementContext() {}

func NewOldStyleDeclarationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OldStyleDeclarationStatementContext {
	var p = new(OldStyleDeclarationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_oldStyleDeclarationStatement

	return p
}

func (s *OldStyleDeclarationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *OldStyleDeclarationStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *OldStyleDeclarationStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *OldStyleDeclarationStatementContext) CREG() antlr.TerminalNode {
	return s.GetToken(qasm3ParserCREG, 0)
}

func (s *OldStyleDeclarationStatementContext) QREG() antlr.TerminalNode {
	return s.GetToken(qasm3ParserQREG, 0)
}

func (s *OldStyleDeclarationStatementContext) Designator() IDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDesignatorContext)
}

func (s *OldStyleDeclarationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OldStyleDeclarationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OldStyleDeclarationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterOldStyleDeclarationStatement(s)
	}
}

func (s *OldStyleDeclarationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitOldStyleDeclarationStatement(s)
	}
}

func (s *OldStyleDeclarationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitOldStyleDeclarationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) OldStyleDeclarationStatement() (localctx IOldStyleDeclarationStatementContext) {
	localctx = NewOldStyleDeclarationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, qasm3ParserRULE_oldStyleDeclarationStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(386)
		_la = p.GetTokenStream().LA(1)

		if !(_la == qasm3ParserQREG || _la == qasm3ParserCREG) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(387)
		p.Match(qasm3ParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(389)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserLBRACKET {
		{
			p.SetState(388)
			p.Designator()
		}

	}
	{
		p.SetState(391)
		p.Match(qasm3ParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuantumDeclarationStatementContext is an interface to support dynamic dispatch.
type IQuantumDeclarationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QubitType() IQubitTypeContext
	Identifier() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode

	// IsQuantumDeclarationStatementContext differentiates from other interfaces.
	IsQuantumDeclarationStatementContext()
}

type QuantumDeclarationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuantumDeclarationStatementContext() *QuantumDeclarationStatementContext {
	var p = new(QuantumDeclarationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_quantumDeclarationStatement
	return p
}

func InitEmptyQuantumDeclarationStatementContext(p *QuantumDeclarationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_quantumDeclarationStatement
}

func (*QuantumDeclarationStatementContext) IsQuantumDeclarationStatementContext() {}

func NewQuantumDeclarationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuantumDeclarationStatementContext {
	var p = new(QuantumDeclarationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_quantumDeclarationStatement

	return p
}

func (s *QuantumDeclarationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *QuantumDeclarationStatementContext) QubitType() IQubitTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQubitTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQubitTypeContext)
}

func (s *QuantumDeclarationStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *QuantumDeclarationStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *QuantumDeclarationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantumDeclarationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuantumDeclarationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterQuantumDeclarationStatement(s)
	}
}

func (s *QuantumDeclarationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitQuantumDeclarationStatement(s)
	}
}

func (s *QuantumDeclarationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitQuantumDeclarationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) QuantumDeclarationStatement() (localctx IQuantumDeclarationStatementContext) {
	localctx = NewQuantumDeclarationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, qasm3ParserRULE_quantumDeclarationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(393)
		p.QubitType()
	}
	{
		p.SetState(394)
		p.Match(qasm3ParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(395)
		p.Match(qasm3ParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefStatementContext is an interface to support dynamic dispatch.
type IDefStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEF() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	Scope() IScopeContext
	ArgumentDefinitionList() IArgumentDefinitionListContext
	ReturnSignature() IReturnSignatureContext

	// IsDefStatementContext differentiates from other interfaces.
	IsDefStatementContext()
}

type DefStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefStatementContext() *DefStatementContext {
	var p = new(DefStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_defStatement
	return p
}

func InitEmptyDefStatementContext(p *DefStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_defStatement
}

func (*DefStatementContext) IsDefStatementContext() {}

func NewDefStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefStatementContext {
	var p = new(DefStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_defStatement

	return p
}

func (s *DefStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DefStatementContext) DEF() antlr.TerminalNode {
	return s.GetToken(qasm3ParserDEF, 0)
}

func (s *DefStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *DefStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLPAREN, 0)
}

func (s *DefStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRPAREN, 0)
}

func (s *DefStatementContext) Scope() IScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScopeContext)
}

func (s *DefStatementContext) ArgumentDefinitionList() IArgumentDefinitionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentDefinitionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentDefinitionListContext)
}

func (s *DefStatementContext) ReturnSignature() IReturnSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnSignatureContext)
}

func (s *DefStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterDefStatement(s)
	}
}

func (s *DefStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitDefStatement(s)
	}
}

func (s *DefStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitDefStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) DefStatement() (localctx IDefStatementContext) {
	localctx = NewDefStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, qasm3ParserRULE_defStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(397)
		p.Match(qasm3ParserDEF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(398)
		p.Match(qasm3ParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(399)
		p.Match(qasm3ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(401)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&14293382725632) != 0 {
		{
			p.SetState(400)
			p.ArgumentDefinitionList()
		}

	}
	{
		p.SetState(403)
		p.Match(qasm3ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(405)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserARROW {
		{
			p.SetState(404)
			p.ReturnSignature()
		}

	}
	{
		p.SetState(407)
		p.Scope()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExternStatementContext is an interface to support dynamic dispatch.
type IExternStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXTERN() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	SEMICOLON() antlr.TerminalNode
	ExternArgumentList() IExternArgumentListContext
	ReturnSignature() IReturnSignatureContext

	// IsExternStatementContext differentiates from other interfaces.
	IsExternStatementContext()
}

type ExternStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternStatementContext() *ExternStatementContext {
	var p = new(ExternStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_externStatement
	return p
}

func InitEmptyExternStatementContext(p *ExternStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_externStatement
}

func (*ExternStatementContext) IsExternStatementContext() {}

func NewExternStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternStatementContext {
	var p = new(ExternStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_externStatement

	return p
}

func (s *ExternStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternStatementContext) EXTERN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserEXTERN, 0)
}

func (s *ExternStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *ExternStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLPAREN, 0)
}

func (s *ExternStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRPAREN, 0)
}

func (s *ExternStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *ExternStatementContext) ExternArgumentList() IExternArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternArgumentListContext)
}

func (s *ExternStatementContext) ReturnSignature() IReturnSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnSignatureContext)
}

func (s *ExternStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterExternStatement(s)
	}
}

func (s *ExternStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitExternStatement(s)
	}
}

func (s *ExternStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitExternStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ExternStatement() (localctx IExternStatementContext) {
	localctx = NewExternStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, qasm3ParserRULE_externStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(409)
		p.Match(qasm3ParserEXTERN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(410)
		p.Match(qasm3ParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(411)
		p.Match(qasm3ParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(413)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&14290161500160) != 0 {
		{
			p.SetState(412)
			p.ExternArgumentList()
		}

	}
	{
		p.SetState(415)
		p.Match(qasm3ParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(417)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserARROW {
		{
			p.SetState(416)
			p.ReturnSignature()
		}

	}
	{
		p.SetState(419)
		p.Match(qasm3ParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGateStatementContext is an interface to support dynamic dispatch.
type IGateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetParams returns the params rule contexts.
	GetParams() IIdentifierListContext

	// GetQubits returns the qubits rule contexts.
	GetQubits() IIdentifierListContext

	// SetParams sets the params rule contexts.
	SetParams(IIdentifierListContext)

	// SetQubits sets the qubits rule contexts.
	SetQubits(IIdentifierListContext)

	// Getter signatures
	GATE() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	Scope() IScopeContext
	AllIdentifierList() []IIdentifierListContext
	IdentifierList(i int) IIdentifierListContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode

	// IsGateStatementContext differentiates from other interfaces.
	IsGateStatementContext()
}

type GateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	params IIdentifierListContext
	qubits IIdentifierListContext
}

func NewEmptyGateStatementContext() *GateStatementContext {
	var p = new(GateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_gateStatement
	return p
}

func InitEmptyGateStatementContext(p *GateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_gateStatement
}

func (*GateStatementContext) IsGateStatementContext() {}

func NewGateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GateStatementContext {
	var p = new(GateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_gateStatement

	return p
}

func (s *GateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GateStatementContext) GetParams() IIdentifierListContext { return s.params }

func (s *GateStatementContext) GetQubits() IIdentifierListContext { return s.qubits }

func (s *GateStatementContext) SetParams(v IIdentifierListContext) { s.params = v }

func (s *GateStatementContext) SetQubits(v IIdentifierListContext) { s.qubits = v }

func (s *GateStatementContext) GATE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserGATE, 0)
}

func (s *GateStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *GateStatementContext) Scope() IScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScopeContext)
}

func (s *GateStatementContext) AllIdentifierList() []IIdentifierListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierListContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierListContext); ok {
			tst[i] = t.(IIdentifierListContext)
			i++
		}
	}

	return tst
}

func (s *GateStatementContext) IdentifierList(i int) IIdentifierListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *GateStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLPAREN, 0)
}

func (s *GateStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRPAREN, 0)
}

func (s *GateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterGateStatement(s)
	}
}

func (s *GateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitGateStatement(s)
	}
}

func (s *GateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitGateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) GateStatement() (localctx IGateStatementContext) {
	localctx = NewGateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, qasm3ParserRULE_gateStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(421)
		p.Match(qasm3ParserGATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(422)
		p.Match(qasm3ParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(428)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserLPAREN {
		{
			p.SetState(423)
			p.Match(qasm3ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(425)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserIdentifier {
			{
				p.SetState(424)

				var _x = p.IdentifierList()

				localctx.(*GateStatementContext).params = _x
			}

		}
		{
			p.SetState(427)
			p.Match(qasm3ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(430)

		var _x = p.IdentifierList()

		localctx.(*GateStatementContext).qubits = _x
	}
	{
		p.SetState(431)
		p.Scope()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentStatementContext is an interface to support dynamic dispatch.
type IAssignmentStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// Getter signatures
	IndexedIdentifier() IIndexedIdentifierContext
	SEMICOLON() antlr.TerminalNode
	EQUALS() antlr.TerminalNode
	CompoundAssignmentOperator() antlr.TerminalNode
	Expression() IExpressionContext
	MeasureExpression() IMeasureExpressionContext

	// IsAssignmentStatementContext differentiates from other interfaces.
	IsAssignmentStatementContext()
}

type AssignmentStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyAssignmentStatementContext() *AssignmentStatementContext {
	var p = new(AssignmentStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_assignmentStatement
	return p
}

func InitEmptyAssignmentStatementContext(p *AssignmentStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_assignmentStatement
}

func (*AssignmentStatementContext) IsAssignmentStatementContext() {}

func NewAssignmentStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentStatementContext {
	var p = new(AssignmentStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_assignmentStatement

	return p
}

func (s *AssignmentStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentStatementContext) GetOp() antlr.Token { return s.op }

func (s *AssignmentStatementContext) SetOp(v antlr.Token) { s.op = v }

func (s *AssignmentStatementContext) IndexedIdentifier() IIndexedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexedIdentifierContext)
}

func (s *AssignmentStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *AssignmentStatementContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(qasm3ParserEQUALS, 0)
}

func (s *AssignmentStatementContext) CompoundAssignmentOperator() antlr.TerminalNode {
	return s.GetToken(qasm3ParserCompoundAssignmentOperator, 0)
}

func (s *AssignmentStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentStatementContext) MeasureExpression() IMeasureExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMeasureExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMeasureExpressionContext)
}

func (s *AssignmentStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterAssignmentStatement(s)
	}
}

func (s *AssignmentStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitAssignmentStatement(s)
	}
}

func (s *AssignmentStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitAssignmentStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) AssignmentStatement() (localctx IAssignmentStatementContext) {
	localctx = NewAssignmentStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, qasm3ParserRULE_assignmentStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(433)
		p.IndexedIdentifier()
	}
	{
		p.SetState(434)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*AssignmentStatementContext).op = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == qasm3ParserEQUALS || _la == qasm3ParserCompoundAssignmentOperator) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*AssignmentStatementContext).op = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(437)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserBOOL, qasm3ParserBIT, qasm3ParserINT, qasm3ParserUINT, qasm3ParserFLOAT, qasm3ParserANGLE, qasm3ParserCOMPLEX, qasm3ParserARRAY, qasm3ParserDURATION, qasm3ParserSTRETCH, qasm3ParserDURATIONOF, qasm3ParserBooleanLiteral, qasm3ParserLPAREN, qasm3ParserMINUS, qasm3ParserTILDE, qasm3ParserEXCLAMATION_POINT, qasm3ParserImaginaryLiteral, qasm3ParserBinaryIntegerLiteral, qasm3ParserOctalIntegerLiteral, qasm3ParserDecimalIntegerLiteral, qasm3ParserHexIntegerLiteral, qasm3ParserIdentifier, qasm3ParserHardwareQubit, qasm3ParserFloatLiteral, qasm3ParserTimingLiteral, qasm3ParserBitstringLiteral:
		{
			p.SetState(435)
			p.expression(0)
		}

	case qasm3ParserMEASURE:
		{
			p.SetState(436)
			p.MeasureExpression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(439)
		p.Match(qasm3ParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionStatementContext is an interface to support dynamic dispatch.
type IExpressionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	SEMICOLON() antlr.TerminalNode

	// IsExpressionStatementContext differentiates from other interfaces.
	IsExpressionStatementContext()
}

type ExpressionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStatementContext() *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_expressionStatement
	return p
}

func InitEmptyExpressionStatementContext(p *ExpressionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_expressionStatement
}

func (*ExpressionStatementContext) IsExpressionStatementContext() {}

func NewExpressionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_expressionStatement

	return p
}

func (s *ExpressionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSEMICOLON, 0)
}

func (s *ExpressionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterExpressionStatement(s)
	}
}

func (s *ExpressionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitExpressionStatement(s)
	}
}

func (s *ExpressionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitExpressionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ExpressionStatement() (localctx IExpressionStatementContext) {
	localctx = NewExpressionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, qasm3ParserRULE_expressionStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(441)
		p.expression(0)
	}
	{
		p.SetState(442)
		p.Match(qasm3ParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICalStatementContext is an interface to support dynamic dispatch.
type ICalStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CAL() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	CalibrationBlock() antlr.TerminalNode

	// IsCalStatementContext differentiates from other interfaces.
	IsCalStatementContext()
}

type CalStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCalStatementContext() *CalStatementContext {
	var p = new(CalStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_calStatement
	return p
}

func InitEmptyCalStatementContext(p *CalStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_calStatement
}

func (*CalStatementContext) IsCalStatementContext() {}

func NewCalStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CalStatementContext {
	var p = new(CalStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_calStatement

	return p
}

func (s *CalStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CalStatementContext) CAL() antlr.TerminalNode {
	return s.GetToken(qasm3ParserCAL, 0)
}

func (s *CalStatementContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLBRACE, 0)
}

func (s *CalStatementContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRBRACE, 0)
}

func (s *CalStatementContext) CalibrationBlock() antlr.TerminalNode {
	return s.GetToken(qasm3ParserCalibrationBlock, 0)
}

func (s *CalStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CalStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CalStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterCalStatement(s)
	}
}

func (s *CalStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitCalStatement(s)
	}
}

func (s *CalStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitCalStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) CalStatement() (localctx ICalStatementContext) {
	localctx = NewCalStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, qasm3ParserRULE_calStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(444)
		p.Match(qasm3ParserCAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(445)
		p.Match(qasm3ParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(447)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserCalibrationBlock {
		{
			p.SetState(446)
			p.Match(qasm3ParserCalibrationBlock)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(449)
		p.Match(qasm3ParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefcalStatementContext is an interface to support dynamic dispatch.
type IDefcalStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFCAL() antlr.TerminalNode
	DefcalTarget() IDefcalTargetContext
	DefcalOperandList() IDefcalOperandListContext
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ReturnSignature() IReturnSignatureContext
	CalibrationBlock() antlr.TerminalNode
	DefcalArgumentDefinitionList() IDefcalArgumentDefinitionListContext

	// IsDefcalStatementContext differentiates from other interfaces.
	IsDefcalStatementContext()
}

type DefcalStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefcalStatementContext() *DefcalStatementContext {
	var p = new(DefcalStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_defcalStatement
	return p
}

func InitEmptyDefcalStatementContext(p *DefcalStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_defcalStatement
}

func (*DefcalStatementContext) IsDefcalStatementContext() {}

func NewDefcalStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefcalStatementContext {
	var p = new(DefcalStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_defcalStatement

	return p
}

func (s *DefcalStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DefcalStatementContext) DEFCAL() antlr.TerminalNode {
	return s.GetToken(qasm3ParserDEFCAL, 0)
}

func (s *DefcalStatementContext) DefcalTarget() IDefcalTargetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefcalTargetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefcalTargetContext)
}

func (s *DefcalStatementContext) DefcalOperandList() IDefcalOperandListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefcalOperandListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefcalOperandListContext)
}

func (s *DefcalStatementContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLBRACE, 0)
}

func (s *DefcalStatementContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRBRACE, 0)
}

func (s *DefcalStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLPAREN, 0)
}

func (s *DefcalStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRPAREN, 0)
}

func (s *DefcalStatementContext) ReturnSignature() IReturnSignatureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnSignatureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnSignatureContext)
}

func (s *DefcalStatementContext) CalibrationBlock() antlr.TerminalNode {
	return s.GetToken(qasm3ParserCalibrationBlock, 0)
}

func (s *DefcalStatementContext) DefcalArgumentDefinitionList() IDefcalArgumentDefinitionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefcalArgumentDefinitionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefcalArgumentDefinitionListContext)
}

func (s *DefcalStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefcalStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefcalStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterDefcalStatement(s)
	}
}

func (s *DefcalStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitDefcalStatement(s)
	}
}

func (s *DefcalStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitDefcalStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) DefcalStatement() (localctx IDefcalStatementContext) {
	localctx = NewDefcalStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, qasm3ParserRULE_defcalStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(451)
		p.Match(qasm3ParserDEFCAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(452)
		p.DefcalTarget()
	}
	p.SetState(458)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserLPAREN {
		{
			p.SetState(453)
			p.Match(qasm3ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(455)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1190091594427006976) != 0) || ((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&268179457) != 0) {
			{
				p.SetState(454)
				p.DefcalArgumentDefinitionList()
			}

		}
		{
			p.SetState(457)
			p.Match(qasm3ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(460)
		p.DefcalOperandList()
	}
	p.SetState(462)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserARROW {
		{
			p.SetState(461)
			p.ReturnSignature()
		}

	}
	{
		p.SetState(464)
		p.Match(qasm3ParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(466)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserCalibrationBlock {
		{
			p.SetState(465)
			p.Match(qasm3ParserCalibrationBlock)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(468)
		p.Match(qasm3ParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) CopyAll(ctx *ExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BitwiseXorExpressionContext struct {
	ExpressionContext
	op antlr.Token
}

func NewBitwiseXorExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitwiseXorExpressionContext {
	var p = new(BitwiseXorExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *BitwiseXorExpressionContext) GetOp() antlr.Token { return s.op }

func (s *BitwiseXorExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *BitwiseXorExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseXorExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitwiseXorExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BitwiseXorExpressionContext) CARET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserCARET, 0)
}

func (s *BitwiseXorExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterBitwiseXorExpression(s)
	}
}

func (s *BitwiseXorExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitBitwiseXorExpression(s)
	}
}

func (s *BitwiseXorExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitBitwiseXorExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type AdditiveExpressionContext struct {
	ExpressionContext
	op antlr.Token
}

func NewAdditiveExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *AdditiveExpressionContext) GetOp() antlr.Token { return s.op }

func (s *AdditiveExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *AdditiveExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AdditiveExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AdditiveExpressionContext) PLUS() antlr.TerminalNode {
	return s.GetToken(qasm3ParserPLUS, 0)
}

func (s *AdditiveExpressionContext) MINUS() antlr.TerminalNode {
	return s.GetToken(qasm3ParserMINUS, 0)
}

func (s *AdditiveExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitAdditiveExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type DurationofExpressionContext struct {
	ExpressionContext
}

func NewDurationofExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DurationofExpressionContext {
	var p = new(DurationofExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *DurationofExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DurationofExpressionContext) DURATIONOF() antlr.TerminalNode {
	return s.GetToken(qasm3ParserDURATIONOF, 0)
}

func (s *DurationofExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLPAREN, 0)
}

func (s *DurationofExpressionContext) Scope() IScopeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScopeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScopeContext)
}

func (s *DurationofExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRPAREN, 0)
}

func (s *DurationofExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterDurationofExpression(s)
	}
}

func (s *DurationofExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitDurationofExpression(s)
	}
}

func (s *DurationofExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitDurationofExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ParenthesisExpressionContext struct {
	ExpressionContext
}

func NewParenthesisExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesisExpressionContext {
	var p = new(ParenthesisExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *ParenthesisExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesisExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLPAREN, 0)
}

func (s *ParenthesisExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesisExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRPAREN, 0)
}

func (s *ParenthesisExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterParenthesisExpression(s)
	}
}

func (s *ParenthesisExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitParenthesisExpression(s)
	}
}

func (s *ParenthesisExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitParenthesisExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ComparisonExpressionContext struct {
	ExpressionContext
	op antlr.Token
}

func NewComparisonExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComparisonExpressionContext {
	var p = new(ComparisonExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *ComparisonExpressionContext) GetOp() antlr.Token { return s.op }

func (s *ComparisonExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *ComparisonExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ComparisonExpressionContext) ComparisonOperator() antlr.TerminalNode {
	return s.GetToken(qasm3ParserComparisonOperator, 0)
}

func (s *ComparisonExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterComparisonExpression(s)
	}
}

func (s *ComparisonExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitComparisonExpression(s)
	}
}

func (s *ComparisonExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitComparisonExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type MultiplicativeExpressionContext struct {
	ExpressionContext
	op antlr.Token
}

func NewMultiplicativeExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *MultiplicativeExpressionContext) GetOp() antlr.Token { return s.op }

func (s *MultiplicativeExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *MultiplicativeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MultiplicativeExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MultiplicativeExpressionContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(qasm3ParserASTERISK, 0)
}

func (s *MultiplicativeExpressionContext) SLASH() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSLASH, 0)
}

func (s *MultiplicativeExpressionContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(qasm3ParserPERCENT, 0)
}

func (s *MultiplicativeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitMultiplicativeExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalOrExpressionContext struct {
	ExpressionContext
	op antlr.Token
}

func NewLogicalOrExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalOrExpressionContext {
	var p = new(LogicalOrExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalOrExpressionContext) GetOp() antlr.Token { return s.op }

func (s *LogicalOrExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *LogicalOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOrExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalOrExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalOrExpressionContext) DOUBLE_PIPE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserDOUBLE_PIPE, 0)
}

func (s *LogicalOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterLogicalOrExpression(s)
	}
}

func (s *LogicalOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitLogicalOrExpression(s)
	}
}

func (s *LogicalOrExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitLogicalOrExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type CastExpressionContext struct {
	ExpressionContext
}

func NewCastExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastExpressionContext {
	var p = new(CastExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *CastExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLPAREN, 0)
}

func (s *CastExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRPAREN, 0)
}

func (s *CastExpressionContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *CastExpressionContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *CastExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterCastExpression(s)
	}
}

func (s *CastExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitCastExpression(s)
	}
}

func (s *CastExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitCastExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PowerExpressionContext struct {
	ExpressionContext
	op antlr.Token
}

func NewPowerExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PowerExpressionContext {
	var p = new(PowerExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *PowerExpressionContext) GetOp() antlr.Token { return s.op }

func (s *PowerExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *PowerExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PowerExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PowerExpressionContext) DOUBLE_ASTERISK() antlr.TerminalNode {
	return s.GetToken(qasm3ParserDOUBLE_ASTERISK, 0)
}

func (s *PowerExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterPowerExpression(s)
	}
}

func (s *PowerExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitPowerExpression(s)
	}
}

func (s *PowerExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitPowerExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitwiseOrExpressionContext struct {
	ExpressionContext
	op antlr.Token
}

func NewBitwiseOrExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitwiseOrExpressionContext {
	var p = new(BitwiseOrExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *BitwiseOrExpressionContext) GetOp() antlr.Token { return s.op }

func (s *BitwiseOrExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *BitwiseOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseOrExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitwiseOrExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BitwiseOrExpressionContext) PIPE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserPIPE, 0)
}

func (s *BitwiseOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterBitwiseOrExpression(s)
	}
}

func (s *BitwiseOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitBitwiseOrExpression(s)
	}
}

func (s *BitwiseOrExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitBitwiseOrExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type CallExpressionContext struct {
	ExpressionContext
}

func NewCallExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CallExpressionContext {
	var p = new(CallExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *CallExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallExpressionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *CallExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLPAREN, 0)
}

func (s *CallExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRPAREN, 0)
}

func (s *CallExpressionContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *CallExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterCallExpression(s)
	}
}

func (s *CallExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitCallExpression(s)
	}
}

func (s *CallExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitCallExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitshiftExpressionContext struct {
	ExpressionContext
	op antlr.Token
}

func NewBitshiftExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitshiftExpressionContext {
	var p = new(BitshiftExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *BitshiftExpressionContext) GetOp() antlr.Token { return s.op }

func (s *BitshiftExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *BitshiftExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitshiftExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitshiftExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BitshiftExpressionContext) BitshiftOperator() antlr.TerminalNode {
	return s.GetToken(qasm3ParserBitshiftOperator, 0)
}

func (s *BitshiftExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterBitshiftExpression(s)
	}
}

func (s *BitshiftExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitBitshiftExpression(s)
	}
}

func (s *BitshiftExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitBitshiftExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type BitwiseAndExpressionContext struct {
	ExpressionContext
	op antlr.Token
}

func NewBitwiseAndExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BitwiseAndExpressionContext {
	var p = new(BitwiseAndExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *BitwiseAndExpressionContext) GetOp() antlr.Token { return s.op }

func (s *BitwiseAndExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *BitwiseAndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitwiseAndExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *BitwiseAndExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BitwiseAndExpressionContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(qasm3ParserAMPERSAND, 0)
}

func (s *BitwiseAndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterBitwiseAndExpression(s)
	}
}

func (s *BitwiseAndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitBitwiseAndExpression(s)
	}
}

func (s *BitwiseAndExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitBitwiseAndExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type EqualityExpressionContext struct {
	ExpressionContext
	op antlr.Token
}

func NewEqualityExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EqualityExpressionContext {
	var p = new(EqualityExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *EqualityExpressionContext) GetOp() antlr.Token { return s.op }

func (s *EqualityExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *EqualityExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *EqualityExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EqualityExpressionContext) EqualityOperator() antlr.TerminalNode {
	return s.GetToken(qasm3ParserEqualityOperator, 0)
}

func (s *EqualityExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterEqualityExpression(s)
	}
}

func (s *EqualityExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitEqualityExpression(s)
	}
}

func (s *EqualityExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitEqualityExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LogicalAndExpressionContext struct {
	ExpressionContext
	op antlr.Token
}

func NewLogicalAndExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalAndExpressionContext {
	var p = new(LogicalAndExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalAndExpressionContext) GetOp() antlr.Token { return s.op }

func (s *LogicalAndExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *LogicalAndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalAndExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalAndExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalAndExpressionContext) DOUBLE_AMPERSAND() antlr.TerminalNode {
	return s.GetToken(qasm3ParserDOUBLE_AMPERSAND, 0)
}

func (s *LogicalAndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterLogicalAndExpression(s)
	}
}

func (s *LogicalAndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitLogicalAndExpression(s)
	}
}

func (s *LogicalAndExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitLogicalAndExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type IndexExpressionContext struct {
	ExpressionContext
}

func NewIndexExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IndexExpressionContext {
	var p = new(IndexExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *IndexExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IndexExpressionContext) IndexOperator() IIndexOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOperatorContext)
}

func (s *IndexExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterIndexExpression(s)
	}
}

func (s *IndexExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitIndexExpression(s)
	}
}

func (s *IndexExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitIndexExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnaryExpressionContext struct {
	ExpressionContext
	op antlr.Token
}

func NewUnaryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryExpressionContext {
	var p = new(UnaryExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *UnaryExpressionContext) GetOp() antlr.Token { return s.op }

func (s *UnaryExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *UnaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UnaryExpressionContext) TILDE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserTILDE, 0)
}

func (s *UnaryExpressionContext) EXCLAMATION_POINT() antlr.TerminalNode {
	return s.GetToken(qasm3ParserEXCLAMATION_POINT, 0)
}

func (s *UnaryExpressionContext) MINUS() antlr.TerminalNode {
	return s.GetToken(qasm3ParserMINUS, 0)
}

func (s *UnaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterUnaryExpression(s)
	}
}

func (s *UnaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitUnaryExpression(s)
	}
}

func (s *UnaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitUnaryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type LiteralExpressionContext struct {
	ExpressionContext
}

func NewLiteralExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralExpressionContext {
	var p = new(LiteralExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *LiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralExpressionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *LiteralExpressionContext) BinaryIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(qasm3ParserBinaryIntegerLiteral, 0)
}

func (s *LiteralExpressionContext) OctalIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(qasm3ParserOctalIntegerLiteral, 0)
}

func (s *LiteralExpressionContext) DecimalIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(qasm3ParserDecimalIntegerLiteral, 0)
}

func (s *LiteralExpressionContext) HexIntegerLiteral() antlr.TerminalNode {
	return s.GetToken(qasm3ParserHexIntegerLiteral, 0)
}

func (s *LiteralExpressionContext) FloatLiteral() antlr.TerminalNode {
	return s.GetToken(qasm3ParserFloatLiteral, 0)
}

func (s *LiteralExpressionContext) ImaginaryLiteral() antlr.TerminalNode {
	return s.GetToken(qasm3ParserImaginaryLiteral, 0)
}

func (s *LiteralExpressionContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(qasm3ParserBooleanLiteral, 0)
}

func (s *LiteralExpressionContext) BitstringLiteral() antlr.TerminalNode {
	return s.GetToken(qasm3ParserBitstringLiteral, 0)
}

func (s *LiteralExpressionContext) TimingLiteral() antlr.TerminalNode {
	return s.GetToken(qasm3ParserTimingLiteral, 0)
}

func (s *LiteralExpressionContext) HardwareQubit() antlr.TerminalNode {
	return s.GetToken(qasm3ParserHardwareQubit, 0)
}

func (s *LiteralExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterLiteralExpression(s)
	}
}

func (s *LiteralExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitLiteralExpression(s)
	}
}

func (s *LiteralExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitLiteralExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *qasm3Parser) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 74
	p.EnterRecursionRule(localctx, 74, qasm3ParserRULE_expression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(497)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext()) {
	case 1:
		localctx = NewParenthesisExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(471)
			p.Match(qasm3ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(472)
			p.expression(0)
		}
		{
			p.SetState(473)
			p.Match(qasm3ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewUnaryExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(475)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*UnaryExpressionContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&6145) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*UnaryExpressionContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(476)
			p.expression(15)
		}

	case 3:
		localctx = NewCastExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(479)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case qasm3ParserBOOL, qasm3ParserBIT, qasm3ParserINT, qasm3ParserUINT, qasm3ParserFLOAT, qasm3ParserANGLE, qasm3ParserCOMPLEX, qasm3ParserDURATION, qasm3ParserSTRETCH:
			{
				p.SetState(477)
				p.ScalarType()
			}

		case qasm3ParserARRAY:
			{
				p.SetState(478)
				p.ArrayType()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(481)
			p.Match(qasm3ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(482)
			p.expression(0)
		}
		{
			p.SetState(483)
			p.Match(qasm3ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewDurationofExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(485)
			p.Match(qasm3ParserDURATIONOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(486)
			p.Match(qasm3ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(487)
			p.Scope()
		}
		{
			p.SetState(488)
			p.Match(qasm3ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewCallExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(490)
			p.Match(qasm3ParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(491)
			p.Match(qasm3ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(493)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1190091586105507840) != 0) || ((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&268179457) != 0) {
			{
				p.SetState(492)
				p.ExpressionList()
			}

		}
		{
			p.SetState(495)
			p.Match(qasm3ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewLiteralExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(496)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-55)) & ^0x3f) == 0 && ((int64(1)<<(_la-55))&8787503087617) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(536)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(534)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext()) {
			case 1:
				localctx = NewPowerExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, qasm3ParserRULE_expression)
				p.SetState(499)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
					goto errorExit
				}
				{
					p.SetState(500)

					var _m = p.Match(qasm3ParserDOUBLE_ASTERISK)

					localctx.(*PowerExpressionContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(501)
					p.expression(16)
				}

			case 2:
				localctx = NewMultiplicativeExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, qasm3ParserRULE_expression)
				p.SetState(502)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
					goto errorExit
				}
				{
					p.SetState(503)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*MultiplicativeExpressionContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((int64((_la-71)) & ^0x3f) == 0 && ((int64(1)<<(_la-71))&13) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*MultiplicativeExpressionContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(504)
					p.expression(15)
				}

			case 3:
				localctx = NewAdditiveExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, qasm3ParserRULE_expression)
				p.SetState(505)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
					goto errorExit
				}
				{
					p.SetState(506)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*AdditiveExpressionContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == qasm3ParserPLUS || _la == qasm3ParserMINUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*AdditiveExpressionContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(507)
					p.expression(14)
				}

			case 4:
				localctx = NewBitshiftExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, qasm3ParserRULE_expression)
				p.SetState(508)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
					goto errorExit
				}
				{
					p.SetState(509)

					var _m = p.Match(qasm3ParserBitshiftOperator)

					localctx.(*BitshiftExpressionContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(510)
					p.expression(13)
				}

			case 5:
				localctx = NewComparisonExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, qasm3ParserRULE_expression)
				p.SetState(511)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
					goto errorExit
				}
				{
					p.SetState(512)

					var _m = p.Match(qasm3ParserComparisonOperator)

					localctx.(*ComparisonExpressionContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(513)
					p.expression(12)
				}

			case 6:
				localctx = NewEqualityExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, qasm3ParserRULE_expression)
				p.SetState(514)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
					goto errorExit
				}
				{
					p.SetState(515)

					var _m = p.Match(qasm3ParserEqualityOperator)

					localctx.(*EqualityExpressionContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(516)
					p.expression(11)
				}

			case 7:
				localctx = NewBitwiseAndExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, qasm3ParserRULE_expression)
				p.SetState(517)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
					goto errorExit
				}
				{
					p.SetState(518)

					var _m = p.Match(qasm3ParserAMPERSAND)

					localctx.(*BitwiseAndExpressionContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(519)
					p.expression(10)
				}

			case 8:
				localctx = NewBitwiseXorExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, qasm3ParserRULE_expression)
				p.SetState(520)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				{
					p.SetState(521)

					var _m = p.Match(qasm3ParserCARET)

					localctx.(*BitwiseXorExpressionContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(522)
					p.expression(9)
				}

			case 9:
				localctx = NewBitwiseOrExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, qasm3ParserRULE_expression)
				p.SetState(523)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(524)

					var _m = p.Match(qasm3ParserPIPE)

					localctx.(*BitwiseOrExpressionContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(525)
					p.expression(8)
				}

			case 10:
				localctx = NewLogicalAndExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, qasm3ParserRULE_expression)
				p.SetState(526)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(527)

					var _m = p.Match(qasm3ParserDOUBLE_AMPERSAND)

					localctx.(*LogicalAndExpressionContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(528)
					p.expression(7)
				}

			case 11:
				localctx = NewLogicalOrExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, qasm3ParserRULE_expression)
				p.SetState(529)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(530)

					var _m = p.Match(qasm3ParserDOUBLE_PIPE)

					localctx.(*LogicalOrExpressionContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(531)
					p.expression(6)
				}

			case 12:
				localctx = NewIndexExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, qasm3ParserRULE_expression)
				p.SetState(532)

				if !(p.Precpred(p.GetParserRuleContext(), 17)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 17)", ""))
					goto errorExit
				}
				{
					p.SetState(533)
					p.IndexOperator()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(538)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAliasExpressionContext is an interface to support dynamic dispatch.
type IAliasExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllDOUBLE_PLUS() []antlr.TerminalNode
	DOUBLE_PLUS(i int) antlr.TerminalNode

	// IsAliasExpressionContext differentiates from other interfaces.
	IsAliasExpressionContext()
}

type AliasExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasExpressionContext() *AliasExpressionContext {
	var p = new(AliasExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_aliasExpression
	return p
}

func InitEmptyAliasExpressionContext(p *AliasExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_aliasExpression
}

func (*AliasExpressionContext) IsAliasExpressionContext() {}

func NewAliasExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasExpressionContext {
	var p = new(AliasExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_aliasExpression

	return p
}

func (s *AliasExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AliasExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AliasExpressionContext) AllDOUBLE_PLUS() []antlr.TerminalNode {
	return s.GetTokens(qasm3ParserDOUBLE_PLUS)
}

func (s *AliasExpressionContext) DOUBLE_PLUS(i int) antlr.TerminalNode {
	return s.GetToken(qasm3ParserDOUBLE_PLUS, i)
}

func (s *AliasExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterAliasExpression(s)
	}
}

func (s *AliasExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitAliasExpression(s)
	}
}

func (s *AliasExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitAliasExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) AliasExpression() (localctx IAliasExpressionContext) {
	localctx = NewAliasExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, qasm3ParserRULE_aliasExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(539)
		p.expression(0)
	}
	p.SetState(544)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == qasm3ParserDOUBLE_PLUS {
		{
			p.SetState(540)
			p.Match(qasm3ParserDOUBLE_PLUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(541)
			p.expression(0)
		}

		p.SetState(546)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclarationExpressionContext is an interface to support dynamic dispatch.
type IDeclarationExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ArrayLiteral() IArrayLiteralContext
	Expression() IExpressionContext
	MeasureExpression() IMeasureExpressionContext

	// IsDeclarationExpressionContext differentiates from other interfaces.
	IsDeclarationExpressionContext()
}

type DeclarationExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationExpressionContext() *DeclarationExpressionContext {
	var p = new(DeclarationExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_declarationExpression
	return p
}

func InitEmptyDeclarationExpressionContext(p *DeclarationExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_declarationExpression
}

func (*DeclarationExpressionContext) IsDeclarationExpressionContext() {}

func NewDeclarationExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationExpressionContext {
	var p = new(DeclarationExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_declarationExpression

	return p
}

func (s *DeclarationExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationExpressionContext) ArrayLiteral() IArrayLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *DeclarationExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DeclarationExpressionContext) MeasureExpression() IMeasureExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMeasureExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMeasureExpressionContext)
}

func (s *DeclarationExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterDeclarationExpression(s)
	}
}

func (s *DeclarationExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitDeclarationExpression(s)
	}
}

func (s *DeclarationExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitDeclarationExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) DeclarationExpression() (localctx IDeclarationExpressionContext) {
	localctx = NewDeclarationExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, qasm3ParserRULE_declarationExpression)
	p.SetState(550)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserLBRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(547)
			p.ArrayLiteral()
		}

	case qasm3ParserBOOL, qasm3ParserBIT, qasm3ParserINT, qasm3ParserUINT, qasm3ParserFLOAT, qasm3ParserANGLE, qasm3ParserCOMPLEX, qasm3ParserARRAY, qasm3ParserDURATION, qasm3ParserSTRETCH, qasm3ParserDURATIONOF, qasm3ParserBooleanLiteral, qasm3ParserLPAREN, qasm3ParserMINUS, qasm3ParserTILDE, qasm3ParserEXCLAMATION_POINT, qasm3ParserImaginaryLiteral, qasm3ParserBinaryIntegerLiteral, qasm3ParserOctalIntegerLiteral, qasm3ParserDecimalIntegerLiteral, qasm3ParserHexIntegerLiteral, qasm3ParserIdentifier, qasm3ParserHardwareQubit, qasm3ParserFloatLiteral, qasm3ParserTimingLiteral, qasm3ParserBitstringLiteral:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(548)
			p.expression(0)
		}

	case qasm3ParserMEASURE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(549)
			p.MeasureExpression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMeasureExpressionContext is an interface to support dynamic dispatch.
type IMeasureExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MEASURE() antlr.TerminalNode
	GateOperand() IGateOperandContext

	// IsMeasureExpressionContext differentiates from other interfaces.
	IsMeasureExpressionContext()
}

type MeasureExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMeasureExpressionContext() *MeasureExpressionContext {
	var p = new(MeasureExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_measureExpression
	return p
}

func InitEmptyMeasureExpressionContext(p *MeasureExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_measureExpression
}

func (*MeasureExpressionContext) IsMeasureExpressionContext() {}

func NewMeasureExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MeasureExpressionContext {
	var p = new(MeasureExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_measureExpression

	return p
}

func (s *MeasureExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MeasureExpressionContext) MEASURE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserMEASURE, 0)
}

func (s *MeasureExpressionContext) GateOperand() IGateOperandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGateOperandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGateOperandContext)
}

func (s *MeasureExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MeasureExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MeasureExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterMeasureExpression(s)
	}
}

func (s *MeasureExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitMeasureExpression(s)
	}
}

func (s *MeasureExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitMeasureExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) MeasureExpression() (localctx IMeasureExpressionContext) {
	localctx = NewMeasureExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, qasm3ParserRULE_measureExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(552)
		p.Match(qasm3ParserMEASURE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(553)
		p.GateOperand()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRangeExpressionContext is an interface to support dynamic dispatch.
type IRangeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCOLON() []antlr.TerminalNode
	COLON(i int) antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsRangeExpressionContext differentiates from other interfaces.
	IsRangeExpressionContext()
}

type RangeExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangeExpressionContext() *RangeExpressionContext {
	var p = new(RangeExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_rangeExpression
	return p
}

func InitEmptyRangeExpressionContext(p *RangeExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_rangeExpression
}

func (*RangeExpressionContext) IsRangeExpressionContext() {}

func NewRangeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangeExpressionContext {
	var p = new(RangeExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_rangeExpression

	return p
}

func (s *RangeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *RangeExpressionContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(qasm3ParserCOLON)
}

func (s *RangeExpressionContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(qasm3ParserCOLON, i)
}

func (s *RangeExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *RangeExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RangeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterRangeExpression(s)
	}
}

func (s *RangeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitRangeExpression(s)
	}
}

func (s *RangeExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitRangeExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) RangeExpression() (localctx IRangeExpressionContext) {
	localctx = NewRangeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, qasm3ParserRULE_rangeExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(556)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1190091586105507840) != 0) || ((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&268179457) != 0) {
		{
			p.SetState(555)
			p.expression(0)
		}

	}
	{
		p.SetState(558)
		p.Match(qasm3ParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(560)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1190091586105507840) != 0) || ((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&268179457) != 0) {
		{
			p.SetState(559)
			p.expression(0)
		}

	}
	p.SetState(564)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserCOLON {
		{
			p.SetState(562)
			p.Match(qasm3ParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(563)
			p.expression(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetExpressionContext is an interface to support dynamic dispatch.
type ISetExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	RBRACE() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSetExpressionContext differentiates from other interfaces.
	IsSetExpressionContext()
}

type SetExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetExpressionContext() *SetExpressionContext {
	var p = new(SetExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_setExpression
	return p
}

func InitEmptySetExpressionContext(p *SetExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_setExpression
}

func (*SetExpressionContext) IsSetExpressionContext() {}

func NewSetExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetExpressionContext {
	var p = new(SetExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_setExpression

	return p
}

func (s *SetExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SetExpressionContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLBRACE, 0)
}

func (s *SetExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SetExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetExpressionContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRBRACE, 0)
}

func (s *SetExpressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(qasm3ParserCOMMA)
}

func (s *SetExpressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(qasm3ParserCOMMA, i)
}

func (s *SetExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterSetExpression(s)
	}
}

func (s *SetExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitSetExpression(s)
	}
}

func (s *SetExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitSetExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) SetExpression() (localctx ISetExpressionContext) {
	localctx = NewSetExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, qasm3ParserRULE_setExpression)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(566)
		p.Match(qasm3ParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(567)
		p.expression(0)
	}
	p.SetState(572)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(568)
				p.Match(qasm3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(569)
				p.expression(0)
			}

		}
		p.SetState(574)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(576)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserCOMMA {
		{
			p.SetState(575)
			p.Match(qasm3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(578)
		p.Match(qasm3ParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayLiteralContext is an interface to support dynamic dispatch.
type IArrayLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllArrayLiteral() []IArrayLiteralContext
	ArrayLiteral(i int) IArrayLiteralContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsArrayLiteralContext differentiates from other interfaces.
	IsArrayLiteralContext()
}

type ArrayLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayLiteralContext() *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_arrayLiteral
	return p
}

func InitEmptyArrayLiteralContext(p *ArrayLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_arrayLiteral
}

func (*ArrayLiteralContext) IsArrayLiteralContext() {}

func NewArrayLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayLiteralContext {
	var p = new(ArrayLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_arrayLiteral

	return p
}

func (s *ArrayLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayLiteralContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLBRACE, 0)
}

func (s *ArrayLiteralContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRBRACE, 0)
}

func (s *ArrayLiteralContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArrayLiteralContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayLiteralContext) AllArrayLiteral() []IArrayLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArrayLiteralContext); ok {
			len++
		}
	}

	tst := make([]IArrayLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArrayLiteralContext); ok {
			tst[i] = t.(IArrayLiteralContext)
			i++
		}
	}

	return tst
}

func (s *ArrayLiteralContext) ArrayLiteral(i int) IArrayLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayLiteralContext)
}

func (s *ArrayLiteralContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(qasm3ParserCOMMA)
}

func (s *ArrayLiteralContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(qasm3ParserCOMMA, i)
}

func (s *ArrayLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitArrayLiteral(s)
	}
}

func (s *ArrayLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitArrayLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ArrayLiteral() (localctx IArrayLiteralContext) {
	localctx = NewArrayLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, qasm3ParserRULE_arrayLiteral)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(580)
		p.Match(qasm3ParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(598)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1478321962257219584) != 0) || ((int64((_la-70)) & ^0x3f) == 0 && ((int64(1)<<(_la-70))&268179457) != 0) {
		p.SetState(583)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case qasm3ParserBOOL, qasm3ParserBIT, qasm3ParserINT, qasm3ParserUINT, qasm3ParserFLOAT, qasm3ParserANGLE, qasm3ParserCOMPLEX, qasm3ParserARRAY, qasm3ParserDURATION, qasm3ParserSTRETCH, qasm3ParserDURATIONOF, qasm3ParserBooleanLiteral, qasm3ParserLPAREN, qasm3ParserMINUS, qasm3ParserTILDE, qasm3ParserEXCLAMATION_POINT, qasm3ParserImaginaryLiteral, qasm3ParserBinaryIntegerLiteral, qasm3ParserOctalIntegerLiteral, qasm3ParserDecimalIntegerLiteral, qasm3ParserHexIntegerLiteral, qasm3ParserIdentifier, qasm3ParserHardwareQubit, qasm3ParserFloatLiteral, qasm3ParserTimingLiteral, qasm3ParserBitstringLiteral:
			{
				p.SetState(581)
				p.expression(0)
			}

		case qasm3ParserLBRACE:
			{
				p.SetState(582)
				p.ArrayLiteral()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(592)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(585)
					p.Match(qasm3ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(588)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case qasm3ParserBOOL, qasm3ParserBIT, qasm3ParserINT, qasm3ParserUINT, qasm3ParserFLOAT, qasm3ParserANGLE, qasm3ParserCOMPLEX, qasm3ParserARRAY, qasm3ParserDURATION, qasm3ParserSTRETCH, qasm3ParserDURATIONOF, qasm3ParserBooleanLiteral, qasm3ParserLPAREN, qasm3ParserMINUS, qasm3ParserTILDE, qasm3ParserEXCLAMATION_POINT, qasm3ParserImaginaryLiteral, qasm3ParserBinaryIntegerLiteral, qasm3ParserOctalIntegerLiteral, qasm3ParserDecimalIntegerLiteral, qasm3ParserHexIntegerLiteral, qasm3ParserIdentifier, qasm3ParserHardwareQubit, qasm3ParserFloatLiteral, qasm3ParserTimingLiteral, qasm3ParserBitstringLiteral:
					{
						p.SetState(586)
						p.expression(0)
					}

				case qasm3ParserLBRACE:
					{
						p.SetState(587)
						p.ArrayLiteral()
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			}
			p.SetState(594)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(596)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserCOMMA {
			{
				p.SetState(595)
				p.Match(qasm3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(600)
		p.Match(qasm3ParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexOperatorContext is an interface to support dynamic dispatch.
type IIndexOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACKET() antlr.TerminalNode
	RBRACKET() antlr.TerminalNode
	SetExpression() ISetExpressionContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllRangeExpression() []IRangeExpressionContext
	RangeExpression(i int) IRangeExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIndexOperatorContext differentiates from other interfaces.
	IsIndexOperatorContext()
}

type IndexOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexOperatorContext() *IndexOperatorContext {
	var p = new(IndexOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_indexOperator
	return p
}

func InitEmptyIndexOperatorContext(p *IndexOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_indexOperator
}

func (*IndexOperatorContext) IsIndexOperatorContext() {}

func NewIndexOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexOperatorContext {
	var p = new(IndexOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_indexOperator

	return p
}

func (s *IndexOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexOperatorContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLBRACKET, 0)
}

func (s *IndexOperatorContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRBRACKET, 0)
}

func (s *IndexOperatorContext) SetExpression() ISetExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetExpressionContext)
}

func (s *IndexOperatorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *IndexOperatorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IndexOperatorContext) AllRangeExpression() []IRangeExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRangeExpressionContext); ok {
			len++
		}
	}

	tst := make([]IRangeExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRangeExpressionContext); ok {
			tst[i] = t.(IRangeExpressionContext)
			i++
		}
	}

	return tst
}

func (s *IndexOperatorContext) RangeExpression(i int) IRangeExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangeExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangeExpressionContext)
}

func (s *IndexOperatorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(qasm3ParserCOMMA)
}

func (s *IndexOperatorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(qasm3ParserCOMMA, i)
}

func (s *IndexOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterIndexOperator(s)
	}
}

func (s *IndexOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitIndexOperator(s)
	}
}

func (s *IndexOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitIndexOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) IndexOperator() (localctx IIndexOperatorContext) {
	localctx = NewIndexOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, qasm3ParserRULE_indexOperator)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(602)
		p.Match(qasm3ParserLBRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(621)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserLBRACE:
		{
			p.SetState(603)
			p.SetExpression()
		}

	case qasm3ParserBOOL, qasm3ParserBIT, qasm3ParserINT, qasm3ParserUINT, qasm3ParserFLOAT, qasm3ParserANGLE, qasm3ParserCOMPLEX, qasm3ParserARRAY, qasm3ParserDURATION, qasm3ParserSTRETCH, qasm3ParserDURATIONOF, qasm3ParserBooleanLiteral, qasm3ParserLPAREN, qasm3ParserCOLON, qasm3ParserMINUS, qasm3ParserTILDE, qasm3ParserEXCLAMATION_POINT, qasm3ParserImaginaryLiteral, qasm3ParserBinaryIntegerLiteral, qasm3ParserOctalIntegerLiteral, qasm3ParserDecimalIntegerLiteral, qasm3ParserHexIntegerLiteral, qasm3ParserIdentifier, qasm3ParserHardwareQubit, qasm3ParserFloatLiteral, qasm3ParserTimingLiteral, qasm3ParserBitstringLiteral:
		p.SetState(606)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 60, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(604)
				p.expression(0)
			}

		case 2:
			{
				p.SetState(605)
				p.RangeExpression()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(615)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(608)
					p.Match(qasm3ParserCOMMA)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(611)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(609)
						p.expression(0)
					}

				case 2:
					{
						p.SetState(610)
						p.RangeExpression()
					}

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}

			}
			p.SetState(617)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(619)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserCOMMA {
			{
				p.SetState(618)
				p.Match(qasm3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(623)
		p.Match(qasm3ParserRBRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexedIdentifierContext is an interface to support dynamic dispatch.
type IIndexedIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	AllIndexOperator() []IIndexOperatorContext
	IndexOperator(i int) IIndexOperatorContext

	// IsIndexedIdentifierContext differentiates from other interfaces.
	IsIndexedIdentifierContext()
}

type IndexedIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexedIdentifierContext() *IndexedIdentifierContext {
	var p = new(IndexedIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_indexedIdentifier
	return p
}

func InitEmptyIndexedIdentifierContext(p *IndexedIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_indexedIdentifier
}

func (*IndexedIdentifierContext) IsIndexedIdentifierContext() {}

func NewIndexedIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexedIdentifierContext {
	var p = new(IndexedIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_indexedIdentifier

	return p
}

func (s *IndexedIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexedIdentifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *IndexedIdentifierContext) AllIndexOperator() []IIndexOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexOperatorContext); ok {
			len++
		}
	}

	tst := make([]IIndexOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexOperatorContext); ok {
			tst[i] = t.(IIndexOperatorContext)
			i++
		}
	}

	return tst
}

func (s *IndexedIdentifierContext) IndexOperator(i int) IIndexOperatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexOperatorContext)
}

func (s *IndexedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexedIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterIndexedIdentifier(s)
	}
}

func (s *IndexedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitIndexedIdentifier(s)
	}
}

func (s *IndexedIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitIndexedIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) IndexedIdentifier() (localctx IIndexedIdentifierContext) {
	localctx = NewIndexedIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, qasm3ParserRULE_indexedIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(625)
		p.Match(qasm3ParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(629)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == qasm3ParserLBRACKET {
		{
			p.SetState(626)
			p.IndexOperator()
		}

		p.SetState(631)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReturnSignatureContext is an interface to support dynamic dispatch.
type IReturnSignatureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARROW() antlr.TerminalNode
	ScalarType() IScalarTypeContext

	// IsReturnSignatureContext differentiates from other interfaces.
	IsReturnSignatureContext()
}

type ReturnSignatureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnSignatureContext() *ReturnSignatureContext {
	var p = new(ReturnSignatureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_returnSignature
	return p
}

func InitEmptyReturnSignatureContext(p *ReturnSignatureContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_returnSignature
}

func (*ReturnSignatureContext) IsReturnSignatureContext() {}

func NewReturnSignatureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnSignatureContext {
	var p = new(ReturnSignatureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_returnSignature

	return p
}

func (s *ReturnSignatureContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnSignatureContext) ARROW() antlr.TerminalNode {
	return s.GetToken(qasm3ParserARROW, 0)
}

func (s *ReturnSignatureContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *ReturnSignatureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnSignatureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnSignatureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterReturnSignature(s)
	}
}

func (s *ReturnSignatureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitReturnSignature(s)
	}
}

func (s *ReturnSignatureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitReturnSignature(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ReturnSignature() (localctx IReturnSignatureContext) {
	localctx = NewReturnSignatureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, qasm3ParserRULE_returnSignature)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(632)
		p.Match(qasm3ParserARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(633)
		p.ScalarType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGateModifierContext is an interface to support dynamic dispatch.
type IGateModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT() antlr.TerminalNode
	INV() antlr.TerminalNode
	POW() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	CTRL() antlr.TerminalNode
	NEGCTRL() antlr.TerminalNode

	// IsGateModifierContext differentiates from other interfaces.
	IsGateModifierContext()
}

type GateModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGateModifierContext() *GateModifierContext {
	var p = new(GateModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_gateModifier
	return p
}

func InitEmptyGateModifierContext(p *GateModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_gateModifier
}

func (*GateModifierContext) IsGateModifierContext() {}

func NewGateModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GateModifierContext {
	var p = new(GateModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_gateModifier

	return p
}

func (s *GateModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *GateModifierContext) AT() antlr.TerminalNode {
	return s.GetToken(qasm3ParserAT, 0)
}

func (s *GateModifierContext) INV() antlr.TerminalNode {
	return s.GetToken(qasm3ParserINV, 0)
}

func (s *GateModifierContext) POW() antlr.TerminalNode {
	return s.GetToken(qasm3ParserPOW, 0)
}

func (s *GateModifierContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLPAREN, 0)
}

func (s *GateModifierContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GateModifierContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRPAREN, 0)
}

func (s *GateModifierContext) CTRL() antlr.TerminalNode {
	return s.GetToken(qasm3ParserCTRL, 0)
}

func (s *GateModifierContext) NEGCTRL() antlr.TerminalNode {
	return s.GetToken(qasm3ParserNEGCTRL, 0)
}

func (s *GateModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GateModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GateModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterGateModifier(s)
	}
}

func (s *GateModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitGateModifier(s)
	}
}

func (s *GateModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitGateModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) GateModifier() (localctx IGateModifierContext) {
	localctx = NewGateModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, qasm3ParserRULE_gateModifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(648)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserINV:
		{
			p.SetState(635)
			p.Match(qasm3ParserINV)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case qasm3ParserPOW:
		{
			p.SetState(636)
			p.Match(qasm3ParserPOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(637)
			p.Match(qasm3ParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(638)
			p.expression(0)
		}
		{
			p.SetState(639)
			p.Match(qasm3ParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case qasm3ParserCTRL, qasm3ParserNEGCTRL:
		{
			p.SetState(641)
			_la = p.GetTokenStream().LA(1)

			if !(_la == qasm3ParserCTRL || _la == qasm3ParserNEGCTRL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(646)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserLPAREN {
			{
				p.SetState(642)
				p.Match(qasm3ParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(643)
				p.expression(0)
			}
			{
				p.SetState(644)
				p.Match(qasm3ParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(650)
		p.Match(qasm3ParserAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScalarTypeContext is an interface to support dynamic dispatch.
type IScalarTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BIT() antlr.TerminalNode
	Designator() IDesignatorContext
	INT() antlr.TerminalNode
	UINT() antlr.TerminalNode
	FLOAT() antlr.TerminalNode
	ANGLE() antlr.TerminalNode
	BOOL() antlr.TerminalNode
	DURATION() antlr.TerminalNode
	STRETCH() antlr.TerminalNode
	COMPLEX() antlr.TerminalNode
	LBRACKET() antlr.TerminalNode
	ScalarType() IScalarTypeContext
	RBRACKET() antlr.TerminalNode

	// IsScalarTypeContext differentiates from other interfaces.
	IsScalarTypeContext()
}

type ScalarTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScalarTypeContext() *ScalarTypeContext {
	var p = new(ScalarTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_scalarType
	return p
}

func InitEmptyScalarTypeContext(p *ScalarTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_scalarType
}

func (*ScalarTypeContext) IsScalarTypeContext() {}

func NewScalarTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScalarTypeContext {
	var p = new(ScalarTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_scalarType

	return p
}

func (s *ScalarTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ScalarTypeContext) BIT() antlr.TerminalNode {
	return s.GetToken(qasm3ParserBIT, 0)
}

func (s *ScalarTypeContext) Designator() IDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDesignatorContext)
}

func (s *ScalarTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(qasm3ParserINT, 0)
}

func (s *ScalarTypeContext) UINT() antlr.TerminalNode {
	return s.GetToken(qasm3ParserUINT, 0)
}

func (s *ScalarTypeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(qasm3ParserFLOAT, 0)
}

func (s *ScalarTypeContext) ANGLE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserANGLE, 0)
}

func (s *ScalarTypeContext) BOOL() antlr.TerminalNode {
	return s.GetToken(qasm3ParserBOOL, 0)
}

func (s *ScalarTypeContext) DURATION() antlr.TerminalNode {
	return s.GetToken(qasm3ParserDURATION, 0)
}

func (s *ScalarTypeContext) STRETCH() antlr.TerminalNode {
	return s.GetToken(qasm3ParserSTRETCH, 0)
}

func (s *ScalarTypeContext) COMPLEX() antlr.TerminalNode {
	return s.GetToken(qasm3ParserCOMPLEX, 0)
}

func (s *ScalarTypeContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLBRACKET, 0)
}

func (s *ScalarTypeContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *ScalarTypeContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRBRACKET, 0)
}

func (s *ScalarTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalarTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScalarTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterScalarType(s)
	}
}

func (s *ScalarTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitScalarType(s)
	}
}

func (s *ScalarTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitScalarType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ScalarType() (localctx IScalarTypeContext) {
	localctx = NewScalarTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, qasm3ParserRULE_scalarType)
	var _la int

	p.SetState(682)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserBIT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(652)
			p.Match(qasm3ParserBIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(654)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserLBRACKET {
			{
				p.SetState(653)
				p.Designator()
			}

		}

	case qasm3ParserINT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(656)
			p.Match(qasm3ParserINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(658)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserLBRACKET {
			{
				p.SetState(657)
				p.Designator()
			}

		}

	case qasm3ParserUINT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(660)
			p.Match(qasm3ParserUINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(662)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserLBRACKET {
			{
				p.SetState(661)
				p.Designator()
			}

		}

	case qasm3ParserFLOAT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(664)
			p.Match(qasm3ParserFLOAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(666)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserLBRACKET {
			{
				p.SetState(665)
				p.Designator()
			}

		}

	case qasm3ParserANGLE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(668)
			p.Match(qasm3ParserANGLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(670)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserLBRACKET {
			{
				p.SetState(669)
				p.Designator()
			}

		}

	case qasm3ParserBOOL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(672)
			p.Match(qasm3ParserBOOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case qasm3ParserDURATION:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(673)
			p.Match(qasm3ParserDURATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case qasm3ParserSTRETCH:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(674)
			p.Match(qasm3ParserSTRETCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case qasm3ParserCOMPLEX:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(675)
			p.Match(qasm3ParserCOMPLEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(680)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserLBRACKET {
			{
				p.SetState(676)
				p.Match(qasm3ParserLBRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(677)
				p.ScalarType()
			}
			{
				p.SetState(678)
				p.Match(qasm3ParserRBRACKET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQubitTypeContext is an interface to support dynamic dispatch.
type IQubitTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUBIT() antlr.TerminalNode
	Designator() IDesignatorContext

	// IsQubitTypeContext differentiates from other interfaces.
	IsQubitTypeContext()
}

type QubitTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQubitTypeContext() *QubitTypeContext {
	var p = new(QubitTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_qubitType
	return p
}

func InitEmptyQubitTypeContext(p *QubitTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_qubitType
}

func (*QubitTypeContext) IsQubitTypeContext() {}

func NewQubitTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QubitTypeContext {
	var p = new(QubitTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_qubitType

	return p
}

func (s *QubitTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *QubitTypeContext) QUBIT() antlr.TerminalNode {
	return s.GetToken(qasm3ParserQUBIT, 0)
}

func (s *QubitTypeContext) Designator() IDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDesignatorContext)
}

func (s *QubitTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QubitTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QubitTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterQubitType(s)
	}
}

func (s *QubitTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitQubitType(s)
	}
}

func (s *QubitTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitQubitType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) QubitType() (localctx IQubitTypeContext) {
	localctx = NewQubitTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, qasm3ParserRULE_qubitType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(684)
		p.Match(qasm3ParserQUBIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(686)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserLBRACKET {
		{
			p.SetState(685)
			p.Designator()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayTypeContext is an interface to support dynamic dispatch.
type IArrayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY() antlr.TerminalNode
	LBRACKET() antlr.TerminalNode
	ScalarType() IScalarTypeContext
	COMMA() antlr.TerminalNode
	ExpressionList() IExpressionListContext
	RBRACKET() antlr.TerminalNode

	// IsArrayTypeContext differentiates from other interfaces.
	IsArrayTypeContext()
}

type ArrayTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayTypeContext() *ArrayTypeContext {
	var p = new(ArrayTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_arrayType
	return p
}

func InitEmptyArrayTypeContext(p *ArrayTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_arrayType
}

func (*ArrayTypeContext) IsArrayTypeContext() {}

func NewArrayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayTypeContext {
	var p = new(ArrayTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_arrayType

	return p
}

func (s *ArrayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayTypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(qasm3ParserARRAY, 0)
}

func (s *ArrayTypeContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLBRACKET, 0)
}

func (s *ArrayTypeContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *ArrayTypeContext) COMMA() antlr.TerminalNode {
	return s.GetToken(qasm3ParserCOMMA, 0)
}

func (s *ArrayTypeContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ArrayTypeContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRBRACKET, 0)
}

func (s *ArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterArrayType(s)
	}
}

func (s *ArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitArrayType(s)
	}
}

func (s *ArrayTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitArrayType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ArrayType() (localctx IArrayTypeContext) {
	localctx = NewArrayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, qasm3ParserRULE_arrayType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(688)
		p.Match(qasm3ParserARRAY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(689)
		p.Match(qasm3ParserLBRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(690)
		p.ScalarType()
	}
	{
		p.SetState(691)
		p.Match(qasm3ParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(692)
		p.ExpressionList()
	}
	{
		p.SetState(693)
		p.Match(qasm3ParserRBRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayReferenceTypeContext is an interface to support dynamic dispatch.
type IArrayReferenceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY() antlr.TerminalNode
	LBRACKET() antlr.TerminalNode
	ScalarType() IScalarTypeContext
	COMMA() antlr.TerminalNode
	RBRACKET() antlr.TerminalNode
	READONLY() antlr.TerminalNode
	MUTABLE() antlr.TerminalNode
	ExpressionList() IExpressionListContext
	DIM() antlr.TerminalNode
	EQUALS() antlr.TerminalNode
	Expression() IExpressionContext

	// IsArrayReferenceTypeContext differentiates from other interfaces.
	IsArrayReferenceTypeContext()
}

type ArrayReferenceTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayReferenceTypeContext() *ArrayReferenceTypeContext {
	var p = new(ArrayReferenceTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_arrayReferenceType
	return p
}

func InitEmptyArrayReferenceTypeContext(p *ArrayReferenceTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_arrayReferenceType
}

func (*ArrayReferenceTypeContext) IsArrayReferenceTypeContext() {}

func NewArrayReferenceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayReferenceTypeContext {
	var p = new(ArrayReferenceTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_arrayReferenceType

	return p
}

func (s *ArrayReferenceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayReferenceTypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(qasm3ParserARRAY, 0)
}

func (s *ArrayReferenceTypeContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLBRACKET, 0)
}

func (s *ArrayReferenceTypeContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *ArrayReferenceTypeContext) COMMA() antlr.TerminalNode {
	return s.GetToken(qasm3ParserCOMMA, 0)
}

func (s *ArrayReferenceTypeContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRBRACKET, 0)
}

func (s *ArrayReferenceTypeContext) READONLY() antlr.TerminalNode {
	return s.GetToken(qasm3ParserREADONLY, 0)
}

func (s *ArrayReferenceTypeContext) MUTABLE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserMUTABLE, 0)
}

func (s *ArrayReferenceTypeContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ArrayReferenceTypeContext) DIM() antlr.TerminalNode {
	return s.GetToken(qasm3ParserDIM, 0)
}

func (s *ArrayReferenceTypeContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(qasm3ParserEQUALS, 0)
}

func (s *ArrayReferenceTypeContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayReferenceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayReferenceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayReferenceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterArrayReferenceType(s)
	}
}

func (s *ArrayReferenceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitArrayReferenceType(s)
	}
}

func (s *ArrayReferenceTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitArrayReferenceType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ArrayReferenceType() (localctx IArrayReferenceTypeContext) {
	localctx = NewArrayReferenceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, qasm3ParserRULE_arrayReferenceType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(695)
		_la = p.GetTokenStream().LA(1)

		if !(_la == qasm3ParserREADONLY || _la == qasm3ParserMUTABLE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(696)
		p.Match(qasm3ParserARRAY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(697)
		p.Match(qasm3ParserLBRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(698)
		p.ScalarType()
	}
	{
		p.SetState(699)
		p.Match(qasm3ParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(704)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserBOOL, qasm3ParserBIT, qasm3ParserINT, qasm3ParserUINT, qasm3ParserFLOAT, qasm3ParserANGLE, qasm3ParserCOMPLEX, qasm3ParserARRAY, qasm3ParserDURATION, qasm3ParserSTRETCH, qasm3ParserDURATIONOF, qasm3ParserBooleanLiteral, qasm3ParserLPAREN, qasm3ParserMINUS, qasm3ParserTILDE, qasm3ParserEXCLAMATION_POINT, qasm3ParserImaginaryLiteral, qasm3ParserBinaryIntegerLiteral, qasm3ParserOctalIntegerLiteral, qasm3ParserDecimalIntegerLiteral, qasm3ParserHexIntegerLiteral, qasm3ParserIdentifier, qasm3ParserHardwareQubit, qasm3ParserFloatLiteral, qasm3ParserTimingLiteral, qasm3ParserBitstringLiteral:
		{
			p.SetState(700)
			p.ExpressionList()
		}

	case qasm3ParserDIM:
		{
			p.SetState(701)
			p.Match(qasm3ParserDIM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(702)
			p.Match(qasm3ParserEQUALS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(703)
			p.expression(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(706)
		p.Match(qasm3ParserRBRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDesignatorContext is an interface to support dynamic dispatch.
type IDesignatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACKET() antlr.TerminalNode
	Expression() IExpressionContext
	RBRACKET() antlr.TerminalNode

	// IsDesignatorContext differentiates from other interfaces.
	IsDesignatorContext()
}

type DesignatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDesignatorContext() *DesignatorContext {
	var p = new(DesignatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_designator
	return p
}

func InitEmptyDesignatorContext(p *DesignatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_designator
}

func (*DesignatorContext) IsDesignatorContext() {}

func NewDesignatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DesignatorContext {
	var p = new(DesignatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_designator

	return p
}

func (s *DesignatorContext) GetParser() antlr.Parser { return s.parser }

func (s *DesignatorContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserLBRACKET, 0)
}

func (s *DesignatorContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DesignatorContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRBRACKET, 0)
}

func (s *DesignatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DesignatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DesignatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterDesignator(s)
	}
}

func (s *DesignatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitDesignator(s)
	}
}

func (s *DesignatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitDesignator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) Designator() (localctx IDesignatorContext) {
	localctx = NewDesignatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, qasm3ParserRULE_designator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(708)
		p.Match(qasm3ParserLBRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(709)
		p.expression(0)
	}
	{
		p.SetState(710)
		p.Match(qasm3ParserRBRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefcalTargetContext is an interface to support dynamic dispatch.
type IDefcalTargetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MEASURE() antlr.TerminalNode
	RESET() antlr.TerminalNode
	DELAY() antlr.TerminalNode
	Identifier() antlr.TerminalNode

	// IsDefcalTargetContext differentiates from other interfaces.
	IsDefcalTargetContext()
}

type DefcalTargetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefcalTargetContext() *DefcalTargetContext {
	var p = new(DefcalTargetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_defcalTarget
	return p
}

func InitEmptyDefcalTargetContext(p *DefcalTargetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_defcalTarget
}

func (*DefcalTargetContext) IsDefcalTargetContext() {}

func NewDefcalTargetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefcalTargetContext {
	var p = new(DefcalTargetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_defcalTarget

	return p
}

func (s *DefcalTargetContext) GetParser() antlr.Parser { return s.parser }

func (s *DefcalTargetContext) MEASURE() antlr.TerminalNode {
	return s.GetToken(qasm3ParserMEASURE, 0)
}

func (s *DefcalTargetContext) RESET() antlr.TerminalNode {
	return s.GetToken(qasm3ParserRESET, 0)
}

func (s *DefcalTargetContext) DELAY() antlr.TerminalNode {
	return s.GetToken(qasm3ParserDELAY, 0)
}

func (s *DefcalTargetContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *DefcalTargetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefcalTargetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefcalTargetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterDefcalTarget(s)
	}
}

func (s *DefcalTargetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitDefcalTarget(s)
	}
}

func (s *DefcalTargetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitDefcalTarget(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) DefcalTarget() (localctx IDefcalTargetContext) {
	localctx = NewDefcalTargetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, qasm3ParserRULE_defcalTarget)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(712)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-51)) & ^0x3f) == 0 && ((int64(1)<<(_la-51))&4398046511111) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefcalArgumentDefinitionContext is an interface to support dynamic dispatch.
type IDefcalArgumentDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	ArgumentDefinition() IArgumentDefinitionContext

	// IsDefcalArgumentDefinitionContext differentiates from other interfaces.
	IsDefcalArgumentDefinitionContext()
}

type DefcalArgumentDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefcalArgumentDefinitionContext() *DefcalArgumentDefinitionContext {
	var p = new(DefcalArgumentDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_defcalArgumentDefinition
	return p
}

func InitEmptyDefcalArgumentDefinitionContext(p *DefcalArgumentDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_defcalArgumentDefinition
}

func (*DefcalArgumentDefinitionContext) IsDefcalArgumentDefinitionContext() {}

func NewDefcalArgumentDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefcalArgumentDefinitionContext {
	var p = new(DefcalArgumentDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_defcalArgumentDefinition

	return p
}

func (s *DefcalArgumentDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *DefcalArgumentDefinitionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DefcalArgumentDefinitionContext) ArgumentDefinition() IArgumentDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentDefinitionContext)
}

func (s *DefcalArgumentDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefcalArgumentDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefcalArgumentDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterDefcalArgumentDefinition(s)
	}
}

func (s *DefcalArgumentDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitDefcalArgumentDefinition(s)
	}
}

func (s *DefcalArgumentDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitDefcalArgumentDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) DefcalArgumentDefinition() (localctx IDefcalArgumentDefinitionContext) {
	localctx = NewDefcalArgumentDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, qasm3ParserRULE_defcalArgumentDefinition)
	p.SetState(716)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(714)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(715)
			p.ArgumentDefinition()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefcalOperandContext is an interface to support dynamic dispatch.
type IDefcalOperandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HardwareQubit() antlr.TerminalNode
	Identifier() antlr.TerminalNode

	// IsDefcalOperandContext differentiates from other interfaces.
	IsDefcalOperandContext()
}

type DefcalOperandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefcalOperandContext() *DefcalOperandContext {
	var p = new(DefcalOperandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_defcalOperand
	return p
}

func InitEmptyDefcalOperandContext(p *DefcalOperandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_defcalOperand
}

func (*DefcalOperandContext) IsDefcalOperandContext() {}

func NewDefcalOperandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefcalOperandContext {
	var p = new(DefcalOperandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_defcalOperand

	return p
}

func (s *DefcalOperandContext) GetParser() antlr.Parser { return s.parser }

func (s *DefcalOperandContext) HardwareQubit() antlr.TerminalNode {
	return s.GetToken(qasm3ParserHardwareQubit, 0)
}

func (s *DefcalOperandContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *DefcalOperandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefcalOperandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefcalOperandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterDefcalOperand(s)
	}
}

func (s *DefcalOperandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitDefcalOperand(s)
	}
}

func (s *DefcalOperandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitDefcalOperand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) DefcalOperand() (localctx IDefcalOperandContext) {
	localctx = NewDefcalOperandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, qasm3ParserRULE_defcalOperand)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(718)
		_la = p.GetTokenStream().LA(1)

		if !(_la == qasm3ParserIdentifier || _la == qasm3ParserHardwareQubit) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGateOperandContext is an interface to support dynamic dispatch.
type IGateOperandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IndexedIdentifier() IIndexedIdentifierContext
	HardwareQubit() antlr.TerminalNode

	// IsGateOperandContext differentiates from other interfaces.
	IsGateOperandContext()
}

type GateOperandContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGateOperandContext() *GateOperandContext {
	var p = new(GateOperandContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_gateOperand
	return p
}

func InitEmptyGateOperandContext(p *GateOperandContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_gateOperand
}

func (*GateOperandContext) IsGateOperandContext() {}

func NewGateOperandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GateOperandContext {
	var p = new(GateOperandContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_gateOperand

	return p
}

func (s *GateOperandContext) GetParser() antlr.Parser { return s.parser }

func (s *GateOperandContext) IndexedIdentifier() IIndexedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexedIdentifierContext)
}

func (s *GateOperandContext) HardwareQubit() antlr.TerminalNode {
	return s.GetToken(qasm3ParserHardwareQubit, 0)
}

func (s *GateOperandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GateOperandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GateOperandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterGateOperand(s)
	}
}

func (s *GateOperandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitGateOperand(s)
	}
}

func (s *GateOperandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitGateOperand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) GateOperand() (localctx IGateOperandContext) {
	localctx = NewGateOperandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, qasm3ParserRULE_gateOperand)
	p.SetState(722)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(720)
			p.IndexedIdentifier()
		}

	case qasm3ParserHardwareQubit:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(721)
			p.Match(qasm3ParserHardwareQubit)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExternArgumentContext is an interface to support dynamic dispatch.
type IExternArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ScalarType() IScalarTypeContext
	ArrayReferenceType() IArrayReferenceTypeContext
	CREG() antlr.TerminalNode
	Designator() IDesignatorContext

	// IsExternArgumentContext differentiates from other interfaces.
	IsExternArgumentContext()
}

type ExternArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternArgumentContext() *ExternArgumentContext {
	var p = new(ExternArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_externArgument
	return p
}

func InitEmptyExternArgumentContext(p *ExternArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_externArgument
}

func (*ExternArgumentContext) IsExternArgumentContext() {}

func NewExternArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternArgumentContext {
	var p = new(ExternArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_externArgument

	return p
}

func (s *ExternArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternArgumentContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *ExternArgumentContext) ArrayReferenceType() IArrayReferenceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayReferenceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayReferenceTypeContext)
}

func (s *ExternArgumentContext) CREG() antlr.TerminalNode {
	return s.GetToken(qasm3ParserCREG, 0)
}

func (s *ExternArgumentContext) Designator() IDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDesignatorContext)
}

func (s *ExternArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterExternArgument(s)
	}
}

func (s *ExternArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitExternArgument(s)
	}
}

func (s *ExternArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitExternArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ExternArgument() (localctx IExternArgumentContext) {
	localctx = NewExternArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, qasm3ParserRULE_externArgument)
	var _la int

	p.SetState(730)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserBOOL, qasm3ParserBIT, qasm3ParserINT, qasm3ParserUINT, qasm3ParserFLOAT, qasm3ParserANGLE, qasm3ParserCOMPLEX, qasm3ParserDURATION, qasm3ParserSTRETCH:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(724)
			p.ScalarType()
		}

	case qasm3ParserREADONLY, qasm3ParserMUTABLE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(725)
			p.ArrayReferenceType()
		}

	case qasm3ParserCREG:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(726)
			p.Match(qasm3ParserCREG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(728)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserLBRACKET {
			{
				p.SetState(727)
				p.Designator()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentDefinitionContext is an interface to support dynamic dispatch.
type IArgumentDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ScalarType() IScalarTypeContext
	Identifier() antlr.TerminalNode
	QubitType() IQubitTypeContext
	CREG() antlr.TerminalNode
	QREG() antlr.TerminalNode
	Designator() IDesignatorContext
	ArrayReferenceType() IArrayReferenceTypeContext

	// IsArgumentDefinitionContext differentiates from other interfaces.
	IsArgumentDefinitionContext()
}

type ArgumentDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentDefinitionContext() *ArgumentDefinitionContext {
	var p = new(ArgumentDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_argumentDefinition
	return p
}

func InitEmptyArgumentDefinitionContext(p *ArgumentDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_argumentDefinition
}

func (*ArgumentDefinitionContext) IsArgumentDefinitionContext() {}

func NewArgumentDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentDefinitionContext {
	var p = new(ArgumentDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_argumentDefinition

	return p
}

func (s *ArgumentDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentDefinitionContext) ScalarType() IScalarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScalarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScalarTypeContext)
}

func (s *ArgumentDefinitionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, 0)
}

func (s *ArgumentDefinitionContext) QubitType() IQubitTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQubitTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQubitTypeContext)
}

func (s *ArgumentDefinitionContext) CREG() antlr.TerminalNode {
	return s.GetToken(qasm3ParserCREG, 0)
}

func (s *ArgumentDefinitionContext) QREG() antlr.TerminalNode {
	return s.GetToken(qasm3ParserQREG, 0)
}

func (s *ArgumentDefinitionContext) Designator() IDesignatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDesignatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDesignatorContext)
}

func (s *ArgumentDefinitionContext) ArrayReferenceType() IArrayReferenceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayReferenceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayReferenceTypeContext)
}

func (s *ArgumentDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterArgumentDefinition(s)
	}
}

func (s *ArgumentDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitArgumentDefinition(s)
	}
}

func (s *ArgumentDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitArgumentDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ArgumentDefinition() (localctx IArgumentDefinitionContext) {
	localctx = NewArgumentDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, qasm3ParserRULE_argumentDefinition)
	var _la int

	p.SetState(746)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case qasm3ParserBOOL, qasm3ParserBIT, qasm3ParserINT, qasm3ParserUINT, qasm3ParserFLOAT, qasm3ParserANGLE, qasm3ParserCOMPLEX, qasm3ParserDURATION, qasm3ParserSTRETCH:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(732)
			p.ScalarType()
		}
		{
			p.SetState(733)
			p.Match(qasm3ParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case qasm3ParserQUBIT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(735)
			p.QubitType()
		}
		{
			p.SetState(736)
			p.Match(qasm3ParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case qasm3ParserQREG, qasm3ParserCREG:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(738)
			_la = p.GetTokenStream().LA(1)

			if !(_la == qasm3ParserQREG || _la == qasm3ParserCREG) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(739)
			p.Match(qasm3ParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(741)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == qasm3ParserLBRACKET {
			{
				p.SetState(740)
				p.Designator()
			}

		}

	case qasm3ParserREADONLY, qasm3ParserMUTABLE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(743)
			p.ArrayReferenceType()
		}
		{
			p.SetState(744)
			p.Match(qasm3ParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentDefinitionListContext is an interface to support dynamic dispatch.
type IArgumentDefinitionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllArgumentDefinition() []IArgumentDefinitionContext
	ArgumentDefinition(i int) IArgumentDefinitionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsArgumentDefinitionListContext differentiates from other interfaces.
	IsArgumentDefinitionListContext()
}

type ArgumentDefinitionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentDefinitionListContext() *ArgumentDefinitionListContext {
	var p = new(ArgumentDefinitionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_argumentDefinitionList
	return p
}

func InitEmptyArgumentDefinitionListContext(p *ArgumentDefinitionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_argumentDefinitionList
}

func (*ArgumentDefinitionListContext) IsArgumentDefinitionListContext() {}

func NewArgumentDefinitionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentDefinitionListContext {
	var p = new(ArgumentDefinitionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_argumentDefinitionList

	return p
}

func (s *ArgumentDefinitionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentDefinitionListContext) AllArgumentDefinition() []IArgumentDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArgumentDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IArgumentDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArgumentDefinitionContext); ok {
			tst[i] = t.(IArgumentDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentDefinitionListContext) ArgumentDefinition(i int) IArgumentDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentDefinitionContext)
}

func (s *ArgumentDefinitionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(qasm3ParserCOMMA)
}

func (s *ArgumentDefinitionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(qasm3ParserCOMMA, i)
}

func (s *ArgumentDefinitionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentDefinitionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentDefinitionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterArgumentDefinitionList(s)
	}
}

func (s *ArgumentDefinitionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitArgumentDefinitionList(s)
	}
}

func (s *ArgumentDefinitionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitArgumentDefinitionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ArgumentDefinitionList() (localctx IArgumentDefinitionListContext) {
	localctx = NewArgumentDefinitionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, qasm3ParserRULE_argumentDefinitionList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(748)
		p.ArgumentDefinition()
	}
	p.SetState(753)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 83, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(749)
				p.Match(qasm3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(750)
				p.ArgumentDefinition()
			}

		}
		p.SetState(755)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 83, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(757)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserCOMMA {
		{
			p.SetState(756)
			p.Match(qasm3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefcalArgumentDefinitionListContext is an interface to support dynamic dispatch.
type IDefcalArgumentDefinitionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDefcalArgumentDefinition() []IDefcalArgumentDefinitionContext
	DefcalArgumentDefinition(i int) IDefcalArgumentDefinitionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDefcalArgumentDefinitionListContext differentiates from other interfaces.
	IsDefcalArgumentDefinitionListContext()
}

type DefcalArgumentDefinitionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefcalArgumentDefinitionListContext() *DefcalArgumentDefinitionListContext {
	var p = new(DefcalArgumentDefinitionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_defcalArgumentDefinitionList
	return p
}

func InitEmptyDefcalArgumentDefinitionListContext(p *DefcalArgumentDefinitionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_defcalArgumentDefinitionList
}

func (*DefcalArgumentDefinitionListContext) IsDefcalArgumentDefinitionListContext() {}

func NewDefcalArgumentDefinitionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefcalArgumentDefinitionListContext {
	var p = new(DefcalArgumentDefinitionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_defcalArgumentDefinitionList

	return p
}

func (s *DefcalArgumentDefinitionListContext) GetParser() antlr.Parser { return s.parser }

func (s *DefcalArgumentDefinitionListContext) AllDefcalArgumentDefinition() []IDefcalArgumentDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDefcalArgumentDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IDefcalArgumentDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDefcalArgumentDefinitionContext); ok {
			tst[i] = t.(IDefcalArgumentDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *DefcalArgumentDefinitionListContext) DefcalArgumentDefinition(i int) IDefcalArgumentDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefcalArgumentDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefcalArgumentDefinitionContext)
}

func (s *DefcalArgumentDefinitionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(qasm3ParserCOMMA)
}

func (s *DefcalArgumentDefinitionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(qasm3ParserCOMMA, i)
}

func (s *DefcalArgumentDefinitionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefcalArgumentDefinitionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefcalArgumentDefinitionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterDefcalArgumentDefinitionList(s)
	}
}

func (s *DefcalArgumentDefinitionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitDefcalArgumentDefinitionList(s)
	}
}

func (s *DefcalArgumentDefinitionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitDefcalArgumentDefinitionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) DefcalArgumentDefinitionList() (localctx IDefcalArgumentDefinitionListContext) {
	localctx = NewDefcalArgumentDefinitionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, qasm3ParserRULE_defcalArgumentDefinitionList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(759)
		p.DefcalArgumentDefinition()
	}
	p.SetState(764)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 85, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(760)
				p.Match(qasm3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(761)
				p.DefcalArgumentDefinition()
			}

		}
		p.SetState(766)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 85, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(768)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserCOMMA {
		{
			p.SetState(767)
			p.Match(qasm3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefcalOperandListContext is an interface to support dynamic dispatch.
type IDefcalOperandListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDefcalOperand() []IDefcalOperandContext
	DefcalOperand(i int) IDefcalOperandContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDefcalOperandListContext differentiates from other interfaces.
	IsDefcalOperandListContext()
}

type DefcalOperandListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefcalOperandListContext() *DefcalOperandListContext {
	var p = new(DefcalOperandListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_defcalOperandList
	return p
}

func InitEmptyDefcalOperandListContext(p *DefcalOperandListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_defcalOperandList
}

func (*DefcalOperandListContext) IsDefcalOperandListContext() {}

func NewDefcalOperandListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefcalOperandListContext {
	var p = new(DefcalOperandListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_defcalOperandList

	return p
}

func (s *DefcalOperandListContext) GetParser() antlr.Parser { return s.parser }

func (s *DefcalOperandListContext) AllDefcalOperand() []IDefcalOperandContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDefcalOperandContext); ok {
			len++
		}
	}

	tst := make([]IDefcalOperandContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDefcalOperandContext); ok {
			tst[i] = t.(IDefcalOperandContext)
			i++
		}
	}

	return tst
}

func (s *DefcalOperandListContext) DefcalOperand(i int) IDefcalOperandContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefcalOperandContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefcalOperandContext)
}

func (s *DefcalOperandListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(qasm3ParserCOMMA)
}

func (s *DefcalOperandListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(qasm3ParserCOMMA, i)
}

func (s *DefcalOperandListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefcalOperandListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefcalOperandListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterDefcalOperandList(s)
	}
}

func (s *DefcalOperandListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitDefcalOperandList(s)
	}
}

func (s *DefcalOperandListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitDefcalOperandList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) DefcalOperandList() (localctx IDefcalOperandListContext) {
	localctx = NewDefcalOperandListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, qasm3ParserRULE_defcalOperandList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(770)
		p.DefcalOperand()
	}
	p.SetState(775)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(771)
				p.Match(qasm3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(772)
				p.DefcalOperand()
			}

		}
		p.SetState(777)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 87, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(779)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserCOMMA {
		{
			p.SetState(778)
			p.Match(qasm3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_expressionList
	return p
}

func InitEmptyExpressionListContext(p *ExpressionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_expressionList
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(qasm3ParserCOMMA)
}

func (s *ExpressionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(qasm3ParserCOMMA, i)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterExpressionList(s)
	}
}

func (s *ExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitExpressionList(s)
	}
}

func (s *ExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ExpressionList() (localctx IExpressionListContext) {
	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, qasm3ParserRULE_expressionList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(781)
		p.expression(0)
	}
	p.SetState(786)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 89, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(782)
				p.Match(qasm3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(783)
				p.expression(0)
			}

		}
		p.SetState(788)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 89, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(790)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserCOMMA {
		{
			p.SetState(789)
			p.Match(qasm3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []antlr.TerminalNode
	Identifier(i int) antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_identifierList
	return p
}

func InitEmptyIdentifierListContext(p *IdentifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_identifierList
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) AllIdentifier() []antlr.TerminalNode {
	return s.GetTokens(qasm3ParserIdentifier)
}

func (s *IdentifierListContext) Identifier(i int) antlr.TerminalNode {
	return s.GetToken(qasm3ParserIdentifier, i)
}

func (s *IdentifierListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(qasm3ParserCOMMA)
}

func (s *IdentifierListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(qasm3ParserCOMMA, i)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterIdentifierList(s)
	}
}

func (s *IdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitIdentifierList(s)
	}
}

func (s *IdentifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitIdentifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) IdentifierList() (localctx IIdentifierListContext) {
	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, qasm3ParserRULE_identifierList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(792)
		p.Match(qasm3ParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(797)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(793)
				p.Match(qasm3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(794)
				p.Match(qasm3ParserIdentifier)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(799)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(801)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserCOMMA {
		{
			p.SetState(800)
			p.Match(qasm3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGateOperandListContext is an interface to support dynamic dispatch.
type IGateOperandListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGateOperand() []IGateOperandContext
	GateOperand(i int) IGateOperandContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsGateOperandListContext differentiates from other interfaces.
	IsGateOperandListContext()
}

type GateOperandListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGateOperandListContext() *GateOperandListContext {
	var p = new(GateOperandListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_gateOperandList
	return p
}

func InitEmptyGateOperandListContext(p *GateOperandListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_gateOperandList
}

func (*GateOperandListContext) IsGateOperandListContext() {}

func NewGateOperandListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GateOperandListContext {
	var p = new(GateOperandListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_gateOperandList

	return p
}

func (s *GateOperandListContext) GetParser() antlr.Parser { return s.parser }

func (s *GateOperandListContext) AllGateOperand() []IGateOperandContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGateOperandContext); ok {
			len++
		}
	}

	tst := make([]IGateOperandContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGateOperandContext); ok {
			tst[i] = t.(IGateOperandContext)
			i++
		}
	}

	return tst
}

func (s *GateOperandListContext) GateOperand(i int) IGateOperandContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGateOperandContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGateOperandContext)
}

func (s *GateOperandListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(qasm3ParserCOMMA)
}

func (s *GateOperandListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(qasm3ParserCOMMA, i)
}

func (s *GateOperandListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GateOperandListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GateOperandListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterGateOperandList(s)
	}
}

func (s *GateOperandListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitGateOperandList(s)
	}
}

func (s *GateOperandListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitGateOperandList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) GateOperandList() (localctx IGateOperandListContext) {
	localctx = NewGateOperandListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, qasm3ParserRULE_gateOperandList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(803)
		p.GateOperand()
	}
	p.SetState(808)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(804)
				p.Match(qasm3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(805)
				p.GateOperand()
			}

		}
		p.SetState(810)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(812)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserCOMMA {
		{
			p.SetState(811)
			p.Match(qasm3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExternArgumentListContext is an interface to support dynamic dispatch.
type IExternArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExternArgument() []IExternArgumentContext
	ExternArgument(i int) IExternArgumentContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExternArgumentListContext differentiates from other interfaces.
	IsExternArgumentListContext()
}

type ExternArgumentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternArgumentListContext() *ExternArgumentListContext {
	var p = new(ExternArgumentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_externArgumentList
	return p
}

func InitEmptyExternArgumentListContext(p *ExternArgumentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = qasm3ParserRULE_externArgumentList
}

func (*ExternArgumentListContext) IsExternArgumentListContext() {}

func NewExternArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternArgumentListContext {
	var p = new(ExternArgumentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = qasm3ParserRULE_externArgumentList

	return p
}

func (s *ExternArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternArgumentListContext) AllExternArgument() []IExternArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExternArgumentContext); ok {
			len++
		}
	}

	tst := make([]IExternArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExternArgumentContext); ok {
			tst[i] = t.(IExternArgumentContext)
			i++
		}
	}

	return tst
}

func (s *ExternArgumentListContext) ExternArgument(i int) IExternArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternArgumentContext)
}

func (s *ExternArgumentListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(qasm3ParserCOMMA)
}

func (s *ExternArgumentListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(qasm3ParserCOMMA, i)
}

func (s *ExternArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.EnterExternArgumentList(s)
	}
}

func (s *ExternArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(qasm3ParserListener); ok {
		listenerT.ExitExternArgumentList(s)
	}
}

func (s *ExternArgumentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case qasm3ParserVisitor:
		return t.VisitExternArgumentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *qasm3Parser) ExternArgumentList() (localctx IExternArgumentListContext) {
	localctx = NewExternArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, qasm3ParserRULE_externArgumentList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(814)
		p.ExternArgument()
	}
	p.SetState(819)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 95, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(815)
				p.Match(qasm3ParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(816)
				p.ExternArgument()
			}

		}
		p.SetState(821)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 95, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(823)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == qasm3ParserCOMMA {
		{
			p.SetState(822)
			p.Match(qasm3ParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *qasm3Parser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 37:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *qasm3Parser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 17)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
